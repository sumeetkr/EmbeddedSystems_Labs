   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 291               		.section	.rodata.str1.1,"aMS",@progbits,1
 292               	.LC0:
 293 0000 6461 726B 		.string	"dark \r"
 293      200D 00
 294               	.LC1:
 295 0007 6461 796C 		.string	"daylight \r"
 295      6967 6874 
 295      200D 00
 296               	.LC2:
 297 0012 726F 6F6D 		.string	"room-light \r"
 297      2D6C 6967 
 297      6874 200D 
 297      00
 298               	.LC3:
 299 001f 4D79 206E 		.string	"My node's address is %d\r\n"
 299      6F64 6527 
 299      7320 6164 
 299      6472 6573 
 299      7320 6973 
 300               	.LC4:
 301 0039 5461 736B 		.string	"Task1 PID=%d\r\n"
 301      3120 5049 
 301      443D 2564 
 301      0D0A 00
 302               	.LC5:
 303 0048 5065 7263 		.string	"Percent humidity (in %%)= %lu, "
 303      656E 7420 
 303      6875 6D69 
 303      6469 7479 
 303      2028 696E 
 304               	.global	__udivdi3
 305               	.LC6:
 306 0068 2044 6967 		.string	" Digital Temperature (in F)= %d, "
 306      6974 616C 
 306      2054 656D 
 306      7065 7261 
 306      7475 7265 
 307               	.LC7:
 308 008a 2041 6D62 		.string	" Ambient light (in lumens)= %d, "
 308      6965 6E74 
 308      206C 6967 
 308      6874 2028 
 308      696E 206C 
 309               	.LC8:
 310 00ab 204C 6967 		.string	" Light type detected as %s\r\n"
 310      6874 2074 
 310      7970 6520 
 310      6465 7465 
 310      6374 6564 
 311               	.global	__muldi3
 312               	.LC9:
 313 00c8 4261 726F 		.string	"Barometric Pressure (in. Hg)= %d, "
 313      6D65 7472 
 313      6963 2050 
 313      7265 7373 
 313      7572 6520 
 314               	.LC10:
 315 00eb 2041 6363 		.string	" Acceleration - X (ft / sec^2) =%d, "
 315      656C 6572 
 315      6174 696F 
 315      6E20 2D20 
 315      5820 2866 
 316               	.LC11:
 317 0110 2041 6363 		.string	" Acceleration - Y (ft / sec^2) =%d\r\n"
 317      656C 6572 
 317      6174 696F 
 317      6E20 2D20 
 317      5920 2866 
 318               	.LC12:
 319 0135 4D6F 7469 		.string	"Motion based on Infrared = Yes "
 319      6F6E 2062 
 319      6173 6564 
 319      206F 6E20 
 319      496E 6672 
 320               	.LC13:
 321 0155 4D6F 7469 		.string	"Motion based on Infrared = No "
 321      6F6E 2062 
 321      6173 6564 
 321      206F 6E20 
 321      496E 6672 
 322               	.LC14:
 323 0174 204D 6F74 		.string	" Motion based on light change = Yes \r"
 323      696F 6E20 
 323      6261 7365 
 323      6420 6F6E 
 323      206C 6967 
 324               	.LC15:
 325 019a 204D 6F74 		.string	" Motion based on light change = No \r"
 325      696F 6E20 
 325      6261 7365 
 325      6420 6F6E 
 325      206C 6967 
 326               		.text
 328               	.global	print_sensor_readings
 330               	print_sensor_readings:
 331               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *  Contributing Authors (specific to this file):
  23:main.c        **** *  Zane Starr
  24:main.c        **** *******************************************************************************/
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** #include <nrk.h>
  28:main.c        **** #include <include.h>
  29:main.c        **** #include <ulib.h>
  30:main.c        **** #include <stdio.h>
  31:main.c        **** #include <avr/sleep.h>
  32:main.c        **** #include <hal.h>
  33:main.c        **** #include <nrk_error.h>
  34:main.c        **** #include <nrk_timer.h>
  35:main.c        **** #include <nrk_driver_list.h>
  36:main.c        **** #include <nrk_driver.h>
  37:main.c        **** #include <ff_basic_sensor.h>
  38:main.c        **** 
  39:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  40:main.c        **** nrk_task_type TaskOne;
  41:main.c        **** void print_sensor_readings(void);
  42:main.c        **** 
  43:main.c        **** nrk_task_type TaskTwo;
  44:main.c        **** NRK_STK Stack2[NRK_APP_STACKSIZE];
  45:main.c        **** void collect_Audio_Data(void);
  46:main.c        **** 
  47:main.c        **** uint16_t * audio_data;
  48:main.c        **** int8_t audio_data_size;
  49:main.c        **** uint16_t calculate_rms(uint16_t audios [], int8_t window_size);
  50:main.c        **** 
  51:main.c        **** void nrk_create_taskset();
  52:main.c        **** void nrk_register_drivers();
  53:main.c        **** uint8_t kill_stack(uint8_t val);
  54:main.c        **** 
  55:main.c        **** int
  56:main.c        **** main ()
  57:main.c        **** {
  58:main.c        ****   uint8_t t;
  59:main.c        ****   nrk_setup_ports();
  60:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        ****   printf( PSTR("starting...\r\n") );
  64:main.c        **** 
  65:main.c        ****   audio_data_size = 30;
  66:main.c        ****   audio_data = malloc(audio_data_size * (sizeof audio_data[0]));
  67:main.c        **** 
  68:main.c        ****   nrk_init();
  69:main.c        ****   nrk_time_set(0,0);
  70:main.c        **** 
  71:main.c        ****   nrk_register_drivers();
  72:main.c        ****   nrk_create_taskset ();
  73:main.c        ****   nrk_start();
  74:main.c        ****   
  75:main.c        ****   return 0;
  76:main.c        **** }
  77:main.c        **** 
  78:main.c        **** void
  79:main.c        **** nrk_create_taskset()
  80:main.c        **** {
  81:main.c        ****   TaskOne.task = print_sensor_readings;
  82:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
  83:main.c        ****   TaskOne.prio = 1;
  84:main.c        ****   TaskOne.FirstActivation = TRUE;
  85:main.c        ****   TaskOne.Type = BASIC_TASK;
  86:main.c        ****   TaskOne.SchType = PREEMPTIVE;
  87:main.c        ****   TaskOne.period.secs = 2;
  88:main.c        ****   TaskOne.period.nano_secs = 0;
  89:main.c        ****   TaskOne.cpu_reserve.secs = 0;
  90:main.c        ****   TaskOne.cpu_reserve.nano_secs = 0;
  91:main.c        ****   TaskOne.offset.secs = 0;
  92:main.c        ****   TaskOne.offset.nano_secs= 0;
  93:main.c        ****   nrk_activate_task (&TaskOne);
  94:main.c        **** 
  95:main.c        ****   nrk_task_set_entry_function( &TaskTwo, collect_Audio_Data);
  96:main.c        ****   nrk_task_set_stk( &TaskTwo, Stack2, NRK_APP_STACKSIZE);
  97:main.c        ****   TaskTwo.prio = 2;
  98:main.c        ****   TaskTwo.FirstActivation = TRUE;
  99:main.c        ****   TaskTwo.Type = BASIC_TASK;
 100:main.c        ****   TaskTwo.SchType = PREEMPTIVE;
 101:main.c        ****   TaskTwo.period.secs = 2;
 102:main.c        ****   TaskTwo.period.nano_secs = 0;
 103:main.c        ****   TaskTwo.cpu_reserve.secs = 1;
 104:main.c        ****   TaskTwo.cpu_reserve.nano_secs = 0;
 105:main.c        ****   TaskTwo.offset.secs = 0;
 106:main.c        ****   TaskTwo.offset.nano_secs= 0;
 107:main.c        ****   nrk_activate_task (&TaskTwo);
 108:main.c        **** }
 109:main.c        **** 
 110:main.c        **** 
 111:main.c        **** void print_sensor_readings()
 112:main.c        **** {
 333               	.LM0:
 334               	.LFBB1:
 335 0000 CF93      		push r28
 336 0002 DF93      		push r29
 337 0004 CDB7      		in r28,__SP_L__
 338 0006 DEB7      		in r29,__SP_H__
 339 0008 2E97      		sbiw r28,14
 340 000a 0FB6      		in __tmp_reg__,__SREG__
 341 000c F894      		cli
 342 000e DEBF      		out __SP_H__,r29
 343 0010 0FBE      		out __SREG__,__tmp_reg__
 344 0012 CDBF      		out __SP_L__,r28
 345               	/* prologue: function */
 346               	/* frame size = 14 */
 347               	/* stack size = 16 */
 348               	.L__stack_usage = 16
 113:main.c        **** uint16_t cnt;
 114:main.c        **** int8_t i,fd,val;
 115:main.c        **** uint16_t buf;
 116:main.c        **** uint16_t buf_last = 0;
 117:main.c        **** uint16_t motions[] = {0,0};
 350               	.LM1:
 351 0014 1A86      		std Y+10,__zero_reg__
 352 0016 1986      		std Y+9,__zero_reg__
 353 0018 1C86      		std Y+12,__zero_reg__
 354 001a 1B86      		std Y+11,__zero_reg__
 118:main.c        **** uint16_t index = 0;
 119:main.c        **** uint64_t bbuf;
 120:main.c        **** 
 121:main.c        ****   printf( "My node's address is %d\r\n",NODE_ADDR );
 356               	.LM2:
 357 001c 1F92      		push __zero_reg__
 358 001e 1F92      		push __zero_reg__
 359 0020 80E0      		ldi r24,lo8(.LC3)
 360 0022 90E0      		ldi r25,hi8(.LC3)
 361 0024 9F93      		push r25
 362 0026 8F93      		push r24
 363 0028 0E94 0000 		call printf
 122:main.c        **** 
 123:main.c        ****   printf( "Task1 PID=%d\r\n",nrk_get_pid());
 365               	.LM3:
 366 002c 0E94 0000 		call nrk_get_pid
 367 0030 1F92      		push __zero_reg__
 368 0032 8F93      		push r24
 369 0034 80E0      		ldi r24,lo8(.LC4)
 370 0036 90E0      		ldi r25,hi8(.LC4)
 371 0038 9F93      		push r25
 372 003a 8F93      		push r24
 373 003c 0E94 0000 		call printf
 124:main.c        **** 
 125:main.c        ****   
 126:main.c        ****   	// Open ADC device as read 
 127:main.c        ****   	fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 375               	.LM4:
 376 0040 65E0      		ldi r22,lo8(5)
 377 0042 83E0      		ldi r24,lo8(3)
 378 0044 0E94 0000 		call nrk_open
 379 0048 382E      		mov r3,r24
 128:main.c        ****   	if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 381               	.LM5:
 382 004a 0FB6      		in __tmp_reg__,__SREG__
 383 004c F894      		cli
 384 004e DEBF      		out __SP_H__,r29
 385 0050 0FBE      		out __SREG__,__tmp_reg__
 386 0052 CDBF      		out __SP_L__,r28
 387 0054 3FEF      		ldi r19,lo8(-1)
 388 0056 8313      		cpse r24,r19
 389 0058 00C0      		rjmp .L2
 391               	.LM6:
 392 005a 80E0      		ldi r24,lo8(__c.3168)
 393 005c 90E0      		ldi r25,hi8(__c.3168)
 394 005e 0E94 0000 		call nrk_kprintf
 395               	.L2:
 112:main.c        **** {
 397               	.LM7:
 398 0062 812C      		mov r8,__zero_reg__
 399 0064 912C      		mov r9,__zero_reg__
 400               	.LBB2:
 129:main.c        **** 
 130:main.c        **** 	cnt=0;
 131:main.c        **** 	while(1) 
 132:main.c        **** 	{
 133:main.c        **** 
 134:main.c        **** 		// humidity = 37% temperature(A) = 59.7F temperature(D) = 77.1F pressure= 29.85inHg  light=259lm 
 135:main.c        **** 		// Example of setting a sensor 
 136:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,HUMIDITY);
 137:main.c        **** 		val=nrk_read(fd,&bbuf,4); //percent humidity
 138:main.c        **** 		// Relative Humidity (%)  linear          |  1 |    0 |         0 |       100 |
 139:main.c        **** 		printf( "Percent humidity (in %%)= %lu, ",bbuf);
 140:main.c        **** 
 141:main.c        **** 	    // | digital_temp | Temperature (digital sensor, F) | linear          |              0.18 |   
 142:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,TEMP2);
 143:main.c        **** 		val=nrk_read(fd,&bbuf,4); 
 144:main.c        **** 		uint16_t temp_converted = ((9*bbuf)/5)+ 32;
 145:main.c        **** 		printf( " Digital Temperature (in F)= %d, ", temp_converted/10);
 146:main.c        **** 
 147:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,LIGHT);
 148:main.c        **** 		val=nrk_read(fd,&buf,2);
 149:main.c        **** 		// light        | Incident Illumination (lumens)  | linear          |                -1 | 1024 | 
 150:main.c        **** 	    char *light_type;
 151:main.c        **** 
 152:main.c        **** 		if(buf > 1000){
 153:main.c        **** 			light_type= "dark \r";
 154:main.c        **** 		}
 155:main.c        **** 		else
 156:main.c        **** 		{
 157:main.c        **** 			if(buf < 580){
 158:main.c        **** 				light_type= "daylight \r";
 159:main.c        **** 			}
 160:main.c        **** 			else
 161:main.c        **** 			{
 162:main.c        **** 				light_type= "room-light \r";
 163:main.c        **** 			}
 164:main.c        **** 		}
 165:main.c        **** 
 166:main.c        **** 	    
 167:main.c        **** 		printf( " Ambient light (in lumens)= %d, ",-1*buf + 1024);
 168:main.c        **** 	    printf( " Light type detected as %s\r\n", light_type);
 169:main.c        **** 		
 170:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,PRESS);
 171:main.c        **** 		val=nrk_read(fd,&bbuf,4);
 172:main.c        **** 		// pressure     | Barometric Pressure (in. Hg)    | linear          | 0.000295780903035 |    0 | 
 173:main.c        **** 		printf( "Barometric Pressure (in. Hg)= %d, ",295*(bbuf)/1000000);
 402               	.LM8:
 403 0066 10E0      		ldi r17,lo8(.LC9)
 404 0068 612E      		mov r6,r17
 405 006a 10E0      		ldi r17,hi8(.LC9)
 406 006c 712E      		mov r7,r17
 174:main.c        **** 		
 175:main.c        **** 		// | acc_x        | Acceleration - X (ft / sec^2)   | linear          |                 1 |    0 
 176:main.c        **** 		// | acc_y        | Acceleration - Y (ft / sec^2)   | linear          |                 1 |    0 
 177:main.c        **** 		// | acc_z        | Acceleration - Z (ft / sec^2)   | linear          |                 1 |    0 
 178:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, ACC_X);
 179:main.c        **** 		val=nrk_read(fd,&buf,2);
 180:main.c        **** 		printf( " Acceleration - X (ft / sec^2) =%d, ",buf);
 408               	.LM9:
 409 006e 00E0      		ldi r16,lo8(.LC10)
 410 0070 402E      		mov r4,r16
 411 0072 00E0      		ldi r16,hi8(.LC10)
 412 0074 502E      		mov r5,r16
 413               	.L9:
 136:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,HUMIDITY);
 415               	.LM10:
 416 0076 4BE0      		ldi r20,lo8(11)
 417 0078 61E0      		ldi r22,lo8(1)
 418 007a 832D      		mov r24,r3
 419 007c 0E94 0000 		call nrk_set_status
 137:main.c        **** 		val=nrk_read(fd,&bbuf,4); //percent humidity
 421               	.LM11:
 422 0080 44E0      		ldi r20,lo8(4)
 423 0082 BE01      		movw r22,r28
 424 0084 6F5F      		subi r22,-1
 425 0086 7F4F      		sbci r23,-1
 426 0088 832D      		mov r24,r3
 427 008a 0E94 0000 		call nrk_read
 139:main.c        **** 		printf( "Percent humidity (in %%)= %lu, ",bbuf);
 429               	.LM12:
 430 008e 8885      		ldd r24,Y+8
 431 0090 8F93      		push r24
 432 0092 8F81      		ldd r24,Y+7
 433 0094 8F93      		push r24
 434 0096 8E81      		ldd r24,Y+6
 435 0098 8F93      		push r24
 436 009a 8D81      		ldd r24,Y+5
 437 009c 8F93      		push r24
 438 009e 8C81      		ldd r24,Y+4
 439 00a0 8F93      		push r24
 440 00a2 8B81      		ldd r24,Y+3
 441 00a4 8F93      		push r24
 442 00a6 8A81      		ldd r24,Y+2
 443 00a8 8F93      		push r24
 444 00aa 8981      		ldd r24,Y+1
 445 00ac 8F93      		push r24
 446 00ae 80E0      		ldi r24,lo8(.LC5)
 447 00b0 90E0      		ldi r25,hi8(.LC5)
 448 00b2 9F93      		push r25
 449 00b4 8F93      		push r24
 450 00b6 0E94 0000 		call printf
 142:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,TEMP2);
 452               	.LM13:
 453 00ba 4AE0      		ldi r20,lo8(10)
 454 00bc 61E0      		ldi r22,lo8(1)
 455 00be 832D      		mov r24,r3
 456 00c0 0E94 0000 		call nrk_set_status
 143:main.c        **** 		val=nrk_read(fd,&bbuf,4); 
 458               	.LM14:
 459 00c4 44E0      		ldi r20,lo8(4)
 460 00c6 BE01      		movw r22,r28
 461 00c8 6F5F      		subi r22,-1
 462 00ca 7F4F      		sbci r23,-1
 463 00cc 832D      		mov r24,r3
 464 00ce 0E94 0000 		call nrk_read
 144:main.c        **** 		uint16_t temp_converted = ((9*bbuf)/5)+ 32;
 466               	.LM15:
 467 00d2 A980      		ldd r10,Y+1
 468 00d4 BA80      		ldd r11,Y+2
 469 00d6 CB80      		ldd r12,Y+3
 470 00d8 DC80      		ldd r13,Y+4
 471 00da ED80      		ldd r14,Y+5
 472 00dc FE80      		ldd r15,Y+6
 473 00de EF81      		ldd r30,Y+7
 474 00e0 1885      		ldd r17,Y+8
 475 00e2 9501      		movw r18,r10
 476 00e4 A601      		movw r20,r12
 477 00e6 B701      		movw r22,r14
 478 00e8 8E2F      		mov r24,r30
 479 00ea 912F      		mov r25,r17
 480 00ec 03E0      		ldi r16,lo8(3)
 481 00ee 0E94 0000 		call __ashldi3
 482 00f2 0E2F      		mov r16,r30
 483 00f4 0E94 0000 		call __adddi3
 484 00f8 B5E0      		ldi r27,lo8(5)
 485 00fa AB2E      		mov r10,r27
 486 00fc B12C      		mov r11,__zero_reg__
 487 00fe C12C      		mov r12,__zero_reg__
 488 0100 D12C      		mov r13,__zero_reg__
 489 0102 E12C      		mov r14,__zero_reg__
 490 0104 F12C      		mov r15,__zero_reg__
 491 0106 00E0      		ldi r16,0
 492 0108 10E0      		ldi r17,0
 493 010a 0E94 0000 		call __udivdi3
 494 010e C901      		movw r24,r18
 495 0110 8096      		adiw r24,32
 145:main.c        **** 		printf( " Digital Temperature (in F)= %d, ", temp_converted/10);
 497               	.LM16:
 498 0112 6AE0      		ldi r22,lo8(10)
 499 0114 70E0      		ldi r23,0
 500 0116 0E94 0000 		call __udivmodhi4
 501 011a 7F93      		push r23
 502 011c 6F93      		push r22
 503 011e 80E0      		ldi r24,lo8(.LC6)
 504 0120 90E0      		ldi r25,hi8(.LC6)
 505 0122 9F93      		push r25
 506 0124 8F93      		push r24
 507 0126 0E94 0000 		call printf
 147:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,LIGHT);
 509               	.LM17:
 510 012a 41E0      		ldi r20,lo8(1)
 511 012c 61E0      		ldi r22,lo8(1)
 512 012e 832D      		mov r24,r3
 513 0130 0E94 0000 		call nrk_set_status
 148:main.c        **** 		val=nrk_read(fd,&buf,2);
 515               	.LM18:
 516 0134 42E0      		ldi r20,lo8(2)
 517 0136 BE01      		movw r22,r28
 518 0138 635F      		subi r22,-13
 519 013a 7F4F      		sbci r23,-1
 520 013c 832D      		mov r24,r3
 521 013e 0E94 0000 		call nrk_read
 152:main.c        **** 		if(buf > 1000){
 523               	.LM19:
 524 0142 8D85      		ldd r24,Y+13
 525 0144 9E85      		ldd r25,Y+14
 526 0146 0FB6      		in __tmp_reg__,__SREG__
 527 0148 F894      		cli
 528 014a DEBF      		out __SP_H__,r29
 529 014c 0FBE      		out __SREG__,__tmp_reg__
 530 014e CDBF      		out __SP_L__,r28
 531 0150 893E      		cpi r24,-23
 532 0152 33E0      		ldi r19,3
 533 0154 9307      		cpc r25,r19
 534 0156 00F4      		brsh .L10
 157:main.c        **** 			if(buf < 580){
 536               	.LM20:
 537 0158 8434      		cpi r24,68
 538 015a 22E0      		ldi r18,2
 539 015c 9207      		cpc r25,r18
 540 015e 00F4      		brsh .L11
 158:main.c        **** 				light_type= "daylight \r";
 542               	.LM21:
 543 0160 00E0      		ldi r16,lo8(.LC1)
 544 0162 10E0      		ldi r17,hi8(.LC1)
 545 0164 00C0      		rjmp .L3
 546               	.L10:
 153:main.c        **** 			light_type= "dark \r";
 548               	.LM22:
 549 0166 00E0      		ldi r16,lo8(.LC0)
 550 0168 10E0      		ldi r17,hi8(.LC0)
 551 016a 00C0      		rjmp .L3
 552               	.L11:
 162:main.c        **** 				light_type= "room-light \r";
 554               	.LM23:
 555 016c 00E0      		ldi r16,lo8(.LC2)
 556 016e 10E0      		ldi r17,hi8(.LC2)
 557               	.L3:
 167:main.c        **** 		printf( " Ambient light (in lumens)= %d, ",-1*buf + 1024);
 559               	.LM24:
 560 0170 20E0      		ldi r18,0
 561 0172 34E0      		ldi r19,lo8(4)
 562 0174 281B      		sub r18,r24
 563 0176 390B      		sbc r19,r25
 564 0178 C901      		movw r24,r18
 565 017a 9F93      		push r25
 566 017c 2F93      		push r18
 567 017e 80E0      		ldi r24,lo8(.LC7)
 568 0180 90E0      		ldi r25,hi8(.LC7)
 569 0182 9F93      		push r25
 570 0184 8F93      		push r24
 571 0186 0E94 0000 		call printf
 168:main.c        **** 	    printf( " Light type detected as %s\r\n", light_type);
 573               	.LM25:
 574 018a 1F93      		push r17
 575 018c 0F93      		push r16
 576 018e 80E0      		ldi r24,lo8(.LC8)
 577 0190 90E0      		ldi r25,hi8(.LC8)
 578 0192 9F93      		push r25
 579 0194 8F93      		push r24
 580 0196 0E94 0000 		call printf
 170:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,PRESS);
 582               	.LM26:
 583 019a 49E0      		ldi r20,lo8(9)
 584 019c 61E0      		ldi r22,lo8(1)
 585 019e 832D      		mov r24,r3
 586 01a0 0E94 0000 		call nrk_set_status
 171:main.c        **** 		val=nrk_read(fd,&bbuf,4);
 588               	.LM27:
 589 01a4 44E0      		ldi r20,lo8(4)
 590 01a6 BE01      		movw r22,r28
 591 01a8 6F5F      		subi r22,-1
 592 01aa 7F4F      		sbci r23,-1
 593 01ac 832D      		mov r24,r3
 594 01ae 0E94 0000 		call nrk_read
 173:main.c        **** 		printf( "Barometric Pressure (in. Hg)= %d, ",295*(bbuf)/1000000);
 596               	.LM28:
 597 01b2 27E2      		ldi r18,lo8(39)
 598 01b4 A22E      		mov r10,r18
 599 01b6 BB24      		clr r11
 600 01b8 B394      		inc r11
 601 01ba C12C      		mov r12,__zero_reg__
 602 01bc D12C      		mov r13,__zero_reg__
 603 01be E12C      		mov r14,__zero_reg__
 604 01c0 F12C      		mov r15,__zero_reg__
 605 01c2 00E0      		ldi r16,0
 606 01c4 10E0      		ldi r17,0
 607 01c6 2981      		ldd r18,Y+1
 608 01c8 3A81      		ldd r19,Y+2
 609 01ca 4B81      		ldd r20,Y+3
 610 01cc 5C81      		ldd r21,Y+4
 611 01ce 6D81      		ldd r22,Y+5
 612 01d0 7E81      		ldd r23,Y+6
 613 01d2 8F81      		ldd r24,Y+7
 614 01d4 9885      		ldd r25,Y+8
 615 01d6 0E94 0000 		call __muldi3
 616 01da E0E4      		ldi r30,lo8(64)
 617 01dc AE2E      		mov r10,r30
 618 01de F2E4      		ldi r31,lo8(66)
 619 01e0 BF2E      		mov r11,r31
 620 01e2 AFE0      		ldi r26,lo8(15)
 621 01e4 CA2E      		mov r12,r26
 622 01e6 0E94 0000 		call __udivdi3
 623 01ea 9F93      		push r25
 624 01ec 8F93      		push r24
 625 01ee 7F93      		push r23
 626 01f0 6F93      		push r22
 627 01f2 5F93      		push r21
 628 01f4 4F93      		push r20
 629 01f6 3F93      		push r19
 630 01f8 2F93      		push r18
 631 01fa 7F92      		push r7
 632 01fc 6F92      		push r6
 633 01fe 0E94 0000 		call printf
 178:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, ACC_X);
 635               	.LM29:
 636 0202 44E0      		ldi r20,lo8(4)
 637 0204 61E0      		ldi r22,lo8(1)
 638 0206 832D      		mov r24,r3
 639 0208 0E94 0000 		call nrk_set_status
 179:main.c        **** 		val=nrk_read(fd,&buf,2);
 641               	.LM30:
 642 020c 42E0      		ldi r20,lo8(2)
 643 020e BE01      		movw r22,r28
 644 0210 635F      		subi r22,-13
 645 0212 7F4F      		sbci r23,-1
 646 0214 832D      		mov r24,r3
 647 0216 0E94 0000 		call nrk_read
 649               	.LM31:
 650 021a 8E85      		ldd r24,Y+14
 651 021c 8F93      		push r24
 652 021e 8D85      		ldd r24,Y+13
 653 0220 8F93      		push r24
 654 0222 5F92      		push r5
 655 0224 4F92      		push r4
 656 0226 0E94 0000 		call printf
 181:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, ACC_Y);
 658               	.LM32:
 659 022a 45E0      		ldi r20,lo8(5)
 660 022c 61E0      		ldi r22,lo8(1)
 661 022e 832D      		mov r24,r3
 662 0230 0E94 0000 		call nrk_set_status
 182:main.c        **** 		val=nrk_read(fd,&buf,2);
 664               	.LM33:
 665 0234 42E0      		ldi r20,lo8(2)
 666 0236 BE01      		movw r22,r28
 667 0238 635F      		subi r22,-13
 668 023a 7F4F      		sbci r23,-1
 669 023c 832D      		mov r24,r3
 670 023e 0E94 0000 		call nrk_read
 183:main.c        **** 		printf( " Acceleration - Y (ft / sec^2) =%d\r\n",buf);
 672               	.LM34:
 673 0242 8E85      		ldd r24,Y+14
 674 0244 8F93      		push r24
 675 0246 8D85      		ldd r24,Y+13
 676 0248 8F93      		push r24
 677 024a 80E0      		ldi r24,lo8(.LC11)
 678 024c 90E0      		ldi r25,hi8(.LC11)
 679 024e 9F93      		push r25
 680 0250 8F93      		push r24
 681 0252 0E94 0000 		call printf
 184:main.c        **** 
 185:main.c        **** 
 186:main.c        **** 		// motion       | Motion Detected (binary)        | threshhold      |               950 |    0 | 
 187:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, MOTION);		
 683               	.LM35:
 684 0256 46E0      		ldi r20,lo8(6)
 685 0258 61E0      		ldi r22,lo8(1)
 686 025a 832D      		mov r24,r3
 687 025c 0E94 0000 		call nrk_set_status
 188:main.c        **** 		val=nrk_read(fd,&buf,2);
 689               	.LM36:
 690 0260 42E0      		ldi r20,lo8(2)
 691 0262 BE01      		movw r22,r28
 692 0264 635F      		subi r22,-13
 693 0266 7F4F      		sbci r23,-1
 694 0268 832D      		mov r24,r3
 695 026a 0E94 0000 		call nrk_read
 189:main.c        **** 		// printf( " Motion value =%d\r\n",buf);
 190:main.c        **** 		if(buf> 990){
 697               	.LM37:
 698 026e 0FB6      		in __tmp_reg__,__SREG__
 699 0270 F894      		cli
 700 0272 DEBF      		out __SP_H__,r29
 701 0274 0FBE      		out __SREG__,__tmp_reg__
 702 0276 CDBF      		out __SP_L__,r28
 703 0278 8D85      		ldd r24,Y+13
 704 027a 9E85      		ldd r25,Y+14
 705 027c 8F3D      		cpi r24,-33
 706 027e 9340      		sbci r25,3
 707 0280 00F0      		brlo .L4
 191:main.c        **** 			printf( "Motion based on Infrared = Yes ");
 709               	.LM38:
 710 0282 80E0      		ldi r24,lo8(.LC12)
 711 0284 90E0      		ldi r25,hi8(.LC12)
 712 0286 00C0      		rjmp .L12
 713               	.L4:
 192:main.c        **** 		}
 193:main.c        **** 		else
 194:main.c        **** 		{
 195:main.c        **** 			printf( "Motion based on Infrared = No ");
 715               	.LM39:
 716 0288 80E0      		ldi r24,lo8(.LC13)
 717 028a 90E0      		ldi r25,hi8(.LC13)
 718               	.L12:
 719 028c 9F93      		push r25
 720 028e 8F93      		push r24
 721 0290 0E94 0000 		call printf
 722 0294 0F90      		pop __tmp_reg__
 723 0296 0F90      		pop __tmp_reg__
 196:main.c        **** 		}
 197:main.c        **** 
 198:main.c        **** 		uint16_t sum = 0;
 199:main.c        **** 	    int size = sizeof(motions)/sizeof(motions[0]);
 200:main.c        **** 		for ( i = 0; i < size; i++ )
 201:main.c        **** 	     {
 202:main.c        **** 	      sum = sum + motions[i];
 725               	.LM40:
 726 0298 0B85      		ldd r16,Y+11
 727 029a 1C85      		ldd r17,Y+12
 728 029c 8985      		ldd r24,Y+9
 729 029e 9A85      		ldd r25,Y+10
 730 02a0 080F      		add r16,r24
 731 02a2 191F      		adc r17,r25
 203:main.c        **** 	     }
 204:main.c        **** 
 205:main.c        **** 		uint16_t avg = sum/size;
 733               	.LM41:
 734 02a4 1695      		lsr r17
 735 02a6 0795      		ror r16
 206:main.c        **** 
 207:main.c        **** 	    nrk_led_clr(RED_LED);
 737               	.LM42:
 738 02a8 80E0      		ldi r24,0
 739 02aa 90E0      		ldi r25,0
 740 02ac 0E94 0000 		call nrk_led_clr
 208:main.c        **** 	    nrk_led_clr(GREEN_LED);
 742               	.LM43:
 743 02b0 81E0      		ldi r24,lo8(1)
 744 02b2 90E0      		ldi r25,0
 745 02b4 0E94 0000 		call nrk_led_clr
 209:main.c        **** 
 210:main.c        **** 	    printf( ":");
 747               	.LM44:
 748 02b8 8AE3      		ldi r24,lo8(58)
 749 02ba 90E0      		ldi r25,0
 750 02bc 0E94 0000 		call putchar
 751               	.LBB3:
 211:main.c        **** 		if( abs(buf - avg) >10)
 753               	.LM45:
 754 02c0 8D85      		ldd r24,Y+13
 755 02c2 9E85      		ldd r25,Y+14
 756 02c4 801B      		sub r24,r16
 757 02c6 910B      		sbc r25,r17
 758 02c8 97FF      		sbrs r25,7
 759 02ca 00C0      		rjmp .L7
 760 02cc 9195      		neg r25
 761 02ce 8195      		neg r24
 762 02d0 9109      		sbc r25,__zero_reg__
 763               	.L7:
 764 02d2 0B97      		sbiw r24,11
 765 02d4 04F0      		brlt .L6
 212:main.c        **** 		//if( abs(buf - buf_last) >2)
 213:main.c        **** 			{ printf(" Motion based on light change = Yes \r\n" );
 767               	.LM46:
 768 02d6 80E0      		ldi r24,lo8(.LC14)
 769 02d8 90E0      		ldi r25,hi8(.LC14)
 770 02da 0E94 0000 		call puts
 214:main.c        **** 		      nrk_led_toggle(RED_LED);
 772               	.LM47:
 773 02de 80E0      		ldi r24,0
 774 02e0 90E0      		ldi r25,0
 775 02e2 00C0      		rjmp .L13
 776               	.L6:
 215:main.c        **** 		  	}
 216:main.c        **** 		else 
 217:main.c        **** 		{
 218:main.c        **** 			printf(" Motion based on light change = No \r\n" );
 778               	.LM48:
 779 02e4 80E0      		ldi r24,lo8(.LC15)
 780 02e6 90E0      		ldi r25,hi8(.LC15)
 781 02e8 0E94 0000 		call puts
 219:main.c        **** 			nrk_led_toggle(GREEN_LED);
 783               	.LM49:
 784 02ec 81E0      		ldi r24,lo8(1)
 785 02ee 90E0      		ldi r25,0
 786               	.L13:
 787 02f0 0E94 0000 		call nrk_led_toggle
 788               	.LBE3:
 220:main.c        **** 		}
 221:main.c        **** 
 222:main.c        **** 		motions[index] = buf;
 790               	.LM50:
 791 02f4 F401      		movw r30,r8
 792 02f6 EE0F      		lsl r30
 793 02f8 FF1F      		rol r31
 794 02fa 81E0      		ldi r24,lo8(1)
 795 02fc 90E0      		ldi r25,0
 796 02fe 8C0F      		add r24,r28
 797 0300 9D1F      		adc r25,r29
 798 0302 E80F      		add r30,r24
 799 0304 F91F      		adc r31,r25
 800 0306 8D85      		ldd r24,Y+13
 801 0308 9E85      		ldd r25,Y+14
 802 030a 9187      		std Z+9,r25
 803 030c 8087      		std Z+8,r24
 223:main.c        **** 
 224:main.c        **** 		buf_last = buf; 
 225:main.c        **** 
 226:main.c        **** 
 227:main.c        **** 		nrk_wait_until_next_period();
 805               	.LM51:
 806 030e 0E94 0000 		call nrk_wait_until_next_period
 228:main.c        **** 		cnt++;
 229:main.c        **** 
 230:main.c        **** 		index++;
 231:main.c        **** 		if(index == size) index =0;
 808               	.LM52:
 809 0312 91E0      		ldi r25,1
 810 0314 8926      		eor r8,r25
 811 0316 00C0      		rjmp .L9
 812               	.LBE2:
 825               	.Lscope1:
 827               		.stabd	78,0,0
 829               	.global	nrk_create_taskset
 831               	nrk_create_taskset:
 832               		.stabd	46,0,0
  80:main.c        **** {
 834               	.LM53:
 835               	.LFBB2:
 836 0318 CF92      		push r12
 837 031a DF92      		push r13
 838 031c EF92      		push r14
 839 031e FF92      		push r15
 840 0320 CF93      		push r28
 841               	/* prologue: function */
 842               	/* frame size = 0 */
 843               	/* stack size = 5 */
 844               	.L__stack_usage = 5
  81:main.c        ****   TaskOne.task = print_sensor_readings;
 846               	.LM54:
 847 0322 80E0      		ldi r24,lo8(gs(print_sensor_readings))
 848 0324 90E0      		ldi r25,hi8(gs(print_sensor_readings))
 849 0326 9093 0000 		sts TaskOne+5+1,r25
 850 032a 8093 0000 		sts TaskOne+5,r24
  82:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
 852               	.LM55:
 853 032e 40E8      		ldi r20,lo8(-128)
 854 0330 50E0      		ldi r21,0
 855 0332 60E0      		ldi r22,lo8(Stack1)
 856 0334 70E0      		ldi r23,hi8(Stack1)
 857 0336 80E0      		ldi r24,lo8(TaskOne)
 858 0338 90E0      		ldi r25,hi8(TaskOne)
 859 033a 0E94 0000 		call nrk_task_set_stk
  83:main.c        ****   TaskOne.prio = 1;
 861               	.LM56:
 862 033e C1E0      		ldi r28,lo8(1)
 863 0340 C093 0000 		sts TaskOne+8,r28
  84:main.c        ****   TaskOne.FirstActivation = TRUE;
 865               	.LM57:
 866 0344 C093 0000 		sts TaskOne+7,r28
  85:main.c        ****   TaskOne.Type = BASIC_TASK;
 868               	.LM58:
 869 0348 C093 0000 		sts TaskOne+9,r28
  86:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 871               	.LM59:
 872 034c C093 0000 		sts TaskOne+10,r28
  87:main.c        ****   TaskOne.period.secs = 2;
 874               	.LM60:
 875 0350 82E0      		ldi r24,lo8(2)
 876 0352 C82E      		mov r12,r24
 877 0354 D12C      		mov r13,__zero_reg__
 878 0356 E12C      		mov r14,__zero_reg__
 879 0358 F12C      		mov r15,__zero_reg__
 880 035a C092 0000 		sts TaskOne+11,r12
 881 035e D092 0000 		sts TaskOne+11+1,r13
 882 0362 E092 0000 		sts TaskOne+11+2,r14
 883 0366 F092 0000 		sts TaskOne+11+3,r15
  88:main.c        ****   TaskOne.period.nano_secs = 0;
 885               	.LM61:
 886 036a 1092 0000 		sts TaskOne+15,__zero_reg__
 887 036e 1092 0000 		sts TaskOne+15+1,__zero_reg__
 888 0372 1092 0000 		sts TaskOne+15+2,__zero_reg__
 889 0376 1092 0000 		sts TaskOne+15+3,__zero_reg__
  89:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 891               	.LM62:
 892 037a 1092 0000 		sts TaskOne+19,__zero_reg__
 893 037e 1092 0000 		sts TaskOne+19+1,__zero_reg__
 894 0382 1092 0000 		sts TaskOne+19+2,__zero_reg__
 895 0386 1092 0000 		sts TaskOne+19+3,__zero_reg__
  90:main.c        ****   TaskOne.cpu_reserve.nano_secs = 0;
 897               	.LM63:
 898 038a 1092 0000 		sts TaskOne+23,__zero_reg__
 899 038e 1092 0000 		sts TaskOne+23+1,__zero_reg__
 900 0392 1092 0000 		sts TaskOne+23+2,__zero_reg__
 901 0396 1092 0000 		sts TaskOne+23+3,__zero_reg__
  91:main.c        ****   TaskOne.offset.secs = 0;
 903               	.LM64:
 904 039a 1092 0000 		sts TaskOne+27,__zero_reg__
 905 039e 1092 0000 		sts TaskOne+27+1,__zero_reg__
 906 03a2 1092 0000 		sts TaskOne+27+2,__zero_reg__
 907 03a6 1092 0000 		sts TaskOne+27+3,__zero_reg__
  92:main.c        ****   TaskOne.offset.nano_secs= 0;
 909               	.LM65:
 910 03aa 1092 0000 		sts TaskOne+31,__zero_reg__
 911 03ae 1092 0000 		sts TaskOne+31+1,__zero_reg__
 912 03b2 1092 0000 		sts TaskOne+31+2,__zero_reg__
 913 03b6 1092 0000 		sts TaskOne+31+3,__zero_reg__
  93:main.c        ****   nrk_activate_task (&TaskOne);
 915               	.LM66:
 916 03ba 80E0      		ldi r24,lo8(TaskOne)
 917 03bc 90E0      		ldi r25,hi8(TaskOne)
 918 03be 0E94 0000 		call nrk_activate_task
  95:main.c        ****   nrk_task_set_entry_function( &TaskTwo, collect_Audio_Data);
 920               	.LM67:
 921 03c2 60E0      		ldi r22,lo8(gs(collect_Audio_Data))
 922 03c4 70E0      		ldi r23,hi8(gs(collect_Audio_Data))
 923 03c6 80E0      		ldi r24,lo8(TaskTwo)
 924 03c8 90E0      		ldi r25,hi8(TaskTwo)
 925 03ca 0E94 0000 		call nrk_task_set_entry_function
  96:main.c        ****   nrk_task_set_stk( &TaskTwo, Stack2, NRK_APP_STACKSIZE);
 927               	.LM68:
 928 03ce 40E8      		ldi r20,lo8(-128)
 929 03d0 50E0      		ldi r21,0
 930 03d2 60E0      		ldi r22,lo8(Stack2)
 931 03d4 70E0      		ldi r23,hi8(Stack2)
 932 03d6 80E0      		ldi r24,lo8(TaskTwo)
 933 03d8 90E0      		ldi r25,hi8(TaskTwo)
 934 03da 0E94 0000 		call nrk_task_set_stk
  97:main.c        ****   TaskTwo.prio = 2;
 936               	.LM69:
 937 03de 82E0      		ldi r24,lo8(2)
 938 03e0 8093 0000 		sts TaskTwo+8,r24
  98:main.c        ****   TaskTwo.FirstActivation = TRUE;
 940               	.LM70:
 941 03e4 C093 0000 		sts TaskTwo+7,r28
  99:main.c        ****   TaskTwo.Type = BASIC_TASK;
 943               	.LM71:
 944 03e8 C093 0000 		sts TaskTwo+9,r28
 100:main.c        ****   TaskTwo.SchType = PREEMPTIVE;
 946               	.LM72:
 947 03ec C093 0000 		sts TaskTwo+10,r28
 101:main.c        ****   TaskTwo.period.secs = 2;
 949               	.LM73:
 950 03f0 C092 0000 		sts TaskTwo+11,r12
 951 03f4 D092 0000 		sts TaskTwo+11+1,r13
 952 03f8 E092 0000 		sts TaskTwo+11+2,r14
 953 03fc F092 0000 		sts TaskTwo+11+3,r15
 102:main.c        ****   TaskTwo.period.nano_secs = 0;
 955               	.LM74:
 956 0400 1092 0000 		sts TaskTwo+15,__zero_reg__
 957 0404 1092 0000 		sts TaskTwo+15+1,__zero_reg__
 958 0408 1092 0000 		sts TaskTwo+15+2,__zero_reg__
 959 040c 1092 0000 		sts TaskTwo+15+3,__zero_reg__
 103:main.c        ****   TaskTwo.cpu_reserve.secs = 1;
 961               	.LM75:
 962 0410 81E0      		ldi r24,lo8(1)
 963 0412 90E0      		ldi r25,0
 964 0414 A0E0      		ldi r26,0
 965 0416 B0E0      		ldi r27,0
 966 0418 8093 0000 		sts TaskTwo+19,r24
 967 041c 9093 0000 		sts TaskTwo+19+1,r25
 968 0420 A093 0000 		sts TaskTwo+19+2,r26
 969 0424 B093 0000 		sts TaskTwo+19+3,r27
 104:main.c        ****   TaskTwo.cpu_reserve.nano_secs = 0;
 971               	.LM76:
 972 0428 1092 0000 		sts TaskTwo+23,__zero_reg__
 973 042c 1092 0000 		sts TaskTwo+23+1,__zero_reg__
 974 0430 1092 0000 		sts TaskTwo+23+2,__zero_reg__
 975 0434 1092 0000 		sts TaskTwo+23+3,__zero_reg__
 105:main.c        ****   TaskTwo.offset.secs = 0;
 977               	.LM77:
 978 0438 1092 0000 		sts TaskTwo+27,__zero_reg__
 979 043c 1092 0000 		sts TaskTwo+27+1,__zero_reg__
 980 0440 1092 0000 		sts TaskTwo+27+2,__zero_reg__
 981 0444 1092 0000 		sts TaskTwo+27+3,__zero_reg__
 106:main.c        ****   TaskTwo.offset.nano_secs= 0;
 983               	.LM78:
 984 0448 1092 0000 		sts TaskTwo+31,__zero_reg__
 985 044c 1092 0000 		sts TaskTwo+31+1,__zero_reg__
 986 0450 1092 0000 		sts TaskTwo+31+2,__zero_reg__
 987 0454 1092 0000 		sts TaskTwo+31+3,__zero_reg__
 107:main.c        ****   nrk_activate_task (&TaskTwo);
 989               	.LM79:
 990 0458 80E0      		ldi r24,lo8(TaskTwo)
 991 045a 90E0      		ldi r25,hi8(TaskTwo)
 992               	/* epilogue start */
 108:main.c        **** }
 994               	.LM80:
 995 045c CF91      		pop r28
 996 045e FF90      		pop r15
 997 0460 EF90      		pop r14
 998 0462 DF90      		pop r13
 999 0464 CF90      		pop r12
 107:main.c        ****   nrk_activate_task (&TaskTwo);
 1001               	.LM81:
 1002 0466 0C94 0000 		jmp nrk_activate_task
 1004               	.Lscope2:
 1006               		.stabd	78,0,0
 1007               	.global	__floatunsisf
 1008               	.global	__fixunssfsi
 1009               		.section	.rodata.str1.1
 1010               	.LC16:
 1011 01bf 2041 7564 		.string	" Audio RMS value =%ld\r\n"
 1011      696F 2052 
 1011      4D53 2076 
 1011      616C 7565 
 1011      203D 256C 
 1012               		.text
 1016               	.global	calculate_rms
 1018               	calculate_rms:
 1019               		.stabd	46,0,0
 232:main.c        **** 	}
 233:main.c        **** }
 234:main.c        **** 
 235:main.c        **** void 
 236:main.c        **** collect_Audio_Data(){
 237:main.c        **** printf( "Task PID=%u\r\n",nrk_get_pid());
 238:main.c        **** 
 239:main.c        **** int8_t fd, val, index;
 240:main.c        **** uint16_t buf;
 241:main.c        **** 
 242:main.c        **** 
 243:main.c        **** // Open ADC device as read 
 244:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 245:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 246:main.c        **** 
 247:main.c        **** 	while(1)
 248:main.c        **** 	{
 249:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO);
 250:main.c        ****     	//8 KHZ sensor
 251:main.c        **** 		nrk_spin_wait_us(125);
 252:main.c        **** 		val=nrk_read(fd,&buf,2);
 253:main.c        **** 
 254:main.c        ****     	// printf( " audio=%d\r\n", buf);
 255:main.c        **** 
 256:main.c        **** 		nrk_led_clr(BLUE_LED);
 257:main.c        **** 		nrk_led_clr(RED_LED);
 258:main.c        **** 		nrk_led_toggle(RED_LED);
 259:main.c        **** 
 260:main.c        **** 		audio_data[index] = buf;
 261:main.c        **** 		index++;
 262:main.c        **** 
 263:main.c        **** 		if(index == audio_data_size)
 264:main.c        **** 		{
 265:main.c        **** 			index =0;
 266:main.c        **** 			calculate_rms(audio_data, audio_data_size);
 267:main.c        **** 			nrk_wait_until_next_period();
 268:main.c        **** 		}
 269:main.c        **** 	}
 270:main.c        **** }
 271:main.c        **** 
 272:main.c        **** uint16_t
 273:main.c        **** calculate_rms(uint16_t audios [], int8_t window_size)
 274:main.c        **** {
 1021               	.LM82:
 1022               	.LFBB3:
 1023 046a CF92      		push r12
 1024 046c DF92      		push r13
 1025 046e EF92      		push r14
 1026 0470 FF92      		push r15
 1027 0472 CF93      		push r28
 1028 0474 DF93      		push r29
 1029               	/* prologue: function */
 1030               	/* frame size = 0 */
 1031               	/* stack size = 6 */
 1032               	.L__stack_usage = 6
 1033 0476 FC01      		movw r30,r24
 1034 0478 D62F      		mov r29,r22
 275:main.c        ****   uint8_t index = 0;
 276:main.c        ****   uint32_t rawrms  =0;
 1036               	.LM83:
 1037 047a C12C      		mov r12,__zero_reg__
 1038 047c D12C      		mov r13,__zero_reg__
 1039 047e 7601      		movw r14,r12
 275:main.c        ****   uint8_t index = 0;
 1041               	.LM84:
 1042 0480 C0E0      		ldi r28,0
 277:main.c        ****   uint32_t rms  = 0;
 278:main.c        **** 
 279:main.c        ****   while(index  < window_size)
 1044               	.LM85:
 1045 0482 462F      		mov r20,r22
 1046 0484 5527      		clr r21
 1047 0486 47FD      		sbrc r20,7
 1048 0488 5095      		com r21
 1049 048a 00C0      		rjmp .L16
 1050               	.L17:
 280:main.c        ****   {
 281:main.c        ****     rawrms += (uint32_t)audios[index] * (uint32_t)audios[index];
 1052               	.LM86:
 1053 048c AA0F      		lsl r26
 1054 048e BB1F      		rol r27
 1055 0490 AE0F      		add r26,r30
 1056 0492 BF1F      		adc r27,r31
 1057 0494 0D90      		ld __tmp_reg__,X+
 1058 0496 BC91      		ld r27,X
 1059 0498 A02D      		mov r26,__tmp_reg__
 1060 049a 9D01      		movw r18,r26
 1061 049c 0E94 0000 		call __umulhisi3
 1062 04a0 C60E      		add r12,r22
 1063 04a2 D71E      		adc r13,r23
 1064 04a4 E81E      		adc r14,r24
 1065 04a6 F91E      		adc r15,r25
 282:main.c        ****     index ++;
 1067               	.LM87:
 1068 04a8 CF5F      		subi r28,lo8(-(1))
 1069               	.L16:
 279:main.c        ****   while(index  < window_size)
 1071               	.LM88:
 1072 04aa AC2F      		mov r26,r28
 1073 04ac B0E0      		ldi r27,0
 1074 04ae A417      		cp r26,r20
 1075 04b0 B507      		cpc r27,r21
 1076 04b2 04F0      		brlt .L17
 283:main.c        ****   }
 284:main.c        **** 
 285:main.c        ****   rms = rawrms / window_size ;
 1078               	.LM89:
 1079 04b4 2D2F      		mov r18,r29
 1080 04b6 3327      		clr r19
 1081 04b8 27FD      		sbrc r18,7
 1082 04ba 3095      		com r19
 1083 04bc 432F      		mov r20,r19
 1084 04be 532F      		mov r21,r19
 1085 04c0 C701      		movw r24,r14
 1086 04c2 B601      		movw r22,r12
 1087 04c4 0E94 0000 		call __udivmodsi4
 286:main.c        ****   rms = sqrt(rms) ;
 1089               	.LM90:
 1090 04c8 CA01      		movw r24,r20
 1091 04ca B901      		movw r22,r18
 1092 04cc 0E94 0000 		call __floatunsisf
 1093 04d0 0E94 0000 		call sqrt
 1094 04d4 0E94 0000 		call __fixunssfsi
 287:main.c        **** 
 288:main.c        ****     // No conversion needed as a =1 and b =0 in linear transformation
 289:main.c        ****     // convert to dB = 20 * log(average / (2 ^ (BitDepth - 1))) 
 290:main.c        ****     printf( " Audio RMS value =%ld\r\n",rms);
 1096               	.LM91:
 1097 04d8 9F93      		push r25
 1098 04da 8F93      		push r24
 1099 04dc 7F93      		push r23
 1100 04de 6F93      		push r22
 1101 04e0 80E0      		ldi r24,lo8(.LC16)
 1102 04e2 90E0      		ldi r25,hi8(.LC16)
 1103 04e4 9F93      		push r25
 1104 04e6 8F93      		push r24
 1105 04e8 0E94 0000 		call printf
 291:main.c        **** 
 292:main.c        ****   return 0;
 1107               	.LM92:
 1108 04ec 0F90      		pop __tmp_reg__
 1109 04ee 0F90      		pop __tmp_reg__
 1110 04f0 0F90      		pop __tmp_reg__
 1111 04f2 0F90      		pop __tmp_reg__
 1112 04f4 0F90      		pop __tmp_reg__
 1113 04f6 0F90      		pop __tmp_reg__
 293:main.c        **** }
 1115               	.LM93:
 1116 04f8 80E0      		ldi r24,0
 1117 04fa 90E0      		ldi r25,0
 1118               	/* epilogue start */
 1119 04fc DF91      		pop r29
 1120 04fe CF91      		pop r28
 1121 0500 FF90      		pop r15
 1122 0502 EF90      		pop r14
 1123 0504 DF90      		pop r13
 1124 0506 CF90      		pop r12
 1125 0508 0895      		ret
 1131               	.Lscope3:
 1133               		.stabd	78,0,0
 1134               		.section	.rodata.str1.1
 1135               	.LC17:
 1136 01d7 5461 736B 		.string	"Task PID=%u\r\n"
 1136      2050 4944 
 1136      3D25 750D 
 1136      0A00 
 1137               		.text
 1139               	.global	collect_Audio_Data
 1141               	collect_Audio_Data:
 1142               		.stabd	46,0,0
 236:main.c        **** collect_Audio_Data(){
 1144               	.LM94:
 1145               	.LFBB4:
 1146 050a CF93      		push r28
 1147 050c DF93      		push r29
 1148 050e 00D0      		rcall .
 1149 0510 CDB7      		in r28,__SP_L__
 1150 0512 DEB7      		in r29,__SP_H__
 1151               	/* prologue: function */
 1152               	/* frame size = 2 */
 1153               	/* stack size = 4 */
 1154               	.L__stack_usage = 4
 237:main.c        **** printf( "Task PID=%u\r\n",nrk_get_pid());
 1156               	.LM95:
 1157 0514 0E94 0000 		call nrk_get_pid
 1158 0518 1F92      		push __zero_reg__
 1159 051a 8F93      		push r24
 1160 051c 80E0      		ldi r24,lo8(.LC17)
 1161 051e 90E0      		ldi r25,hi8(.LC17)
 1162 0520 9F93      		push r25
 1163 0522 8F93      		push r24
 1164 0524 0E94 0000 		call printf
 244:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 1166               	.LM96:
 1167 0528 65E0      		ldi r22,lo8(5)
 1168 052a 83E0      		ldi r24,lo8(3)
 1169 052c 0E94 0000 		call nrk_open
 1170 0530 E82E      		mov r14,r24
 245:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 1172               	.LM97:
 1173 0532 0F90      		pop __tmp_reg__
 1174 0534 0F90      		pop __tmp_reg__
 1175 0536 0F90      		pop __tmp_reg__
 1176 0538 0F90      		pop __tmp_reg__
 1177 053a 8FEF      		ldi r24,lo8(-1)
 1178 053c E812      		cpse r14,r24
 1179 053e 00C0      		rjmp .L23
 245:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 1181               	.LM98:
 1182 0540 80E0      		ldi r24,lo8(__c.3186)
 1183 0542 90E0      		ldi r25,hi8(__c.3186)
 1184 0544 0E94 0000 		call nrk_kprintf
 1185               	.L23:
 236:main.c        **** collect_Audio_Data(){
 1187               	.LM99:
 1188 0548 00E0      		ldi r16,0
 1189 054a 10E0      		ldi r17,0
 1190 054c F12C      		mov r15,__zero_reg__
 1191               	.L20:
 249:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO);
 1193               	.LM100:
 1194 054e 43E0      		ldi r20,lo8(3)
 1195 0550 61E0      		ldi r22,lo8(1)
 1196 0552 8E2D      		mov r24,r14
 1197 0554 0E94 0000 		call nrk_set_status
 251:main.c        **** 		nrk_spin_wait_us(125);
 1199               	.LM101:
 1200 0558 8DE7      		ldi r24,lo8(125)
 1201 055a 90E0      		ldi r25,0
 1202 055c 0E94 0000 		call nrk_spin_wait_us
 252:main.c        **** 		val=nrk_read(fd,&buf,2);
 1204               	.LM102:
 1205 0560 42E0      		ldi r20,lo8(2)
 1206 0562 BE01      		movw r22,r28
 1207 0564 6F5F      		subi r22,-1
 1208 0566 7F4F      		sbci r23,-1
 1209 0568 8E2D      		mov r24,r14
 1210 056a 0E94 0000 		call nrk_read
 256:main.c        **** 		nrk_led_clr(BLUE_LED);
 1212               	.LM103:
 1213 056e 83E0      		ldi r24,lo8(3)
 1214 0570 90E0      		ldi r25,0
 1215 0572 0E94 0000 		call nrk_led_clr
 257:main.c        **** 		nrk_led_clr(RED_LED);
 1217               	.LM104:
 1218 0576 80E0      		ldi r24,0
 1219 0578 90E0      		ldi r25,0
 1220 057a 0E94 0000 		call nrk_led_clr
 258:main.c        **** 		nrk_led_toggle(RED_LED);
 1222               	.LM105:
 1223 057e 80E0      		ldi r24,0
 1224 0580 90E0      		ldi r25,0
 1225 0582 0E94 0000 		call nrk_led_toggle
 260:main.c        **** 		audio_data[index] = buf;
 1227               	.LM106:
 1228 0586 2091 0000 		lds r18,audio_data
 1229 058a 3091 0000 		lds r19,audio_data+1
 1230 058e 4981      		ldd r20,Y+1
 1231 0590 5A81      		ldd r21,Y+2
 1232 0592 F901      		movw r30,r18
 1233 0594 E00F      		add r30,r16
 1234 0596 F11F      		adc r31,r17
 1235 0598 5183      		std Z+1,r21
 1236 059a 4083      		st Z,r20
 261:main.c        **** 		index++;
 1238               	.LM107:
 1239 059c F394      		inc r15
 263:main.c        **** 		if(index == audio_data_size)
 1241               	.LM108:
 1242 059e 8091 0000 		lds r24,audio_data_size
 1243 05a2 0E5F      		subi r16,-2
 1244 05a4 1F4F      		sbci r17,-1
 1245 05a6 F812      		cpse r15,r24
 1246 05a8 00C0      		rjmp .L20
 266:main.c        **** 			calculate_rms(audio_data, audio_data_size);
 1248               	.LM109:
 1249 05aa 6F2D      		mov r22,r15
 1250 05ac C901      		movw r24,r18
 1251 05ae 0E94 0000 		call calculate_rms
 267:main.c        **** 			nrk_wait_until_next_period();
 1253               	.LM110:
 1254 05b2 0E94 0000 		call nrk_wait_until_next_period
 1255 05b6 00C0      		rjmp .L23
 1262               	.Lscope4:
 1264               		.stabd	78,0,0
 1266               	.global	nrk_register_drivers
 1268               	nrk_register_drivers:
 1269               		.stabd	46,0,0
 294:main.c        **** 
 295:main.c        **** 
 296:main.c        **** void nrk_register_drivers()
 297:main.c        **** {
 1271               	.LM111:
 1272               	.LFBB5:
 1273               	/* prologue: function */
 1274               	/* frame size = 0 */
 1275               	/* stack size = 0 */
 1276               	.L__stack_usage = 0
 298:main.c        **** int8_t val;
 299:main.c        **** 
 300:main.c        **** // Register the Basic FireFly Sensor device driver
 301:main.c        **** // Make sure to add: 
 302:main.c        **** //     #define NRK_MAX_DRIVER_CNT  
 303:main.c        **** //     in nrk_cfg.h
 304:main.c        **** // Make sure to add: 
 305:main.c        **** //     SRC += $(ROOT_DIR)/src/drivers/platform/$(PLATFORM_TYPE)/source/ff_basic_sensor.c
 306:main.c        **** //     in makefile
 307:main.c        **** val=nrk_register_driver( &dev_manager_ff3_sensors,FIREFLY_3_SENSOR_BASIC);
 1278               	.LM112:
 1279 05b8 63E0      		ldi r22,lo8(3)
 1280 05ba 80E0      		ldi r24,lo8(gs(dev_manager_ff3_sensors))
 1281 05bc 90E0      		ldi r25,hi8(gs(dev_manager_ff3_sensors))
 1282 05be 0E94 0000 		call nrk_register_driver
 308:main.c        **** if(val==NRK_ERROR) nrk_kprintf( PSTR("Failed to load my ADC driver\r\n") );
 1284               	.LM113:
 1285 05c2 8F3F      		cpi r24,lo8(-1)
 1286 05c4 01F4      		brne .L24
 1288               	.LM114:
 1289 05c6 80E0      		ldi r24,lo8(__c.3203)
 1290 05c8 90E0      		ldi r25,hi8(__c.3203)
 1291 05ca 0C94 0000 		jmp nrk_kprintf
 1292               	.L24:
 1293 05ce 0895      		ret
 1295               	.Lscope5:
 1297               		.stabd	78,0,0
 1298               		.section	.rodata.str1.1
 1299               	.LC18:
 1300 01e5 7374 6172 		.string	"starting...\r"
 1300      7469 6E67 
 1300      2E2E 2E0D 
 1300      00
 1301               		.section	.text.startup,"ax",@progbits
 1303               	.global	main
 1305               	main:
 1306               		.stabd	46,0,0
  57:main.c        **** {
 1308               	.LM115:
 1309               	.LFBB6:
 1310               	/* prologue: function */
 1311               	/* frame size = 0 */
 1312               	/* stack size = 0 */
 1313               	.L__stack_usage = 0
  59:main.c        ****   nrk_setup_ports();
 1315               	.LM116:
 1316 0000 0E94 0000 		call nrk_setup_ports
  60:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 1318               	.LM117:
 1319 0004 80E1      		ldi r24,lo8(16)
 1320 0006 90E0      		ldi r25,0
 1321 0008 0E94 0000 		call nrk_setup_uart
  63:main.c        ****   printf( PSTR("starting...\r\n") );
 1323               	.LM118:
 1324 000c 80E0      		ldi r24,lo8(.LC18)
 1325 000e 90E0      		ldi r25,hi8(.LC18)
 1326 0010 0E94 0000 		call puts
  65:main.c        ****   audio_data_size = 30;
 1328               	.LM119:
 1329 0014 8EE1      		ldi r24,lo8(30)
 1330 0016 8093 0000 		sts audio_data_size,r24
  66:main.c        ****   audio_data = malloc(audio_data_size * (sizeof audio_data[0]));
 1332               	.LM120:
 1333 001a 8CE3      		ldi r24,lo8(60)
 1334 001c 90E0      		ldi r25,0
 1335 001e 0E94 0000 		call malloc
 1336 0022 8093 0000 		sts audio_data,r24
 1337 0026 9093 0000 		sts audio_data+1,r25
  68:main.c        ****   nrk_init();
 1339               	.LM121:
 1340 002a 0E94 0000 		call nrk_init
  69:main.c        ****   nrk_time_set(0,0);
 1342               	.LM122:
 1343 002e 20E0      		ldi r18,0
 1344 0030 30E0      		ldi r19,0
 1345 0032 A901      		movw r20,r18
 1346 0034 60E0      		ldi r22,0
 1347 0036 70E0      		ldi r23,0
 1348 0038 CB01      		movw r24,r22
 1349 003a 0E94 0000 		call nrk_time_set
  71:main.c        ****   nrk_register_drivers();
 1351               	.LM123:
 1352 003e 0E94 0000 		call nrk_register_drivers
  72:main.c        ****   nrk_create_taskset ();
 1354               	.LM124:
 1355 0042 0E94 0000 		call nrk_create_taskset
  73:main.c        ****   nrk_start();
 1357               	.LM125:
 1358 0046 0E94 0000 		call nrk_start
  76:main.c        **** }
 1360               	.LM126:
 1361 004a 80E0      		ldi r24,0
 1362 004c 90E0      		ldi r25,0
 1363 004e 0895      		ret
 1365               	.Lscope6:
 1367               		.stabd	78,0,0
 1368               		.comm	audio_data_size,1,1
 1369               		.comm	audio_data,2,1
 1370               		.comm	Stack2,128,1
 1371               		.comm	TaskTwo,35,1
 1372               		.comm	TaskOne,35,1
 1373               		.comm	Stack1,128,1
 1374               		.comm	app_timer0_prescale,1,1
 1375               		.comm	app_timer0_callback,2,1
 1376               		.comm	_nrk_time_trigger,1,1
 1377               		.comm	_nrk_prev_timer_val,1,1
 1378               		.comm	error_num,1,1
 1379               		.comm	error_task,1,1
 1380               		.comm	nrk_kernel_stk_ptr,2,1
 1381               		.comm	nrk_idle_task_stk,128,1
 1382               		.comm	_nrk_signal_list,4,1
 1383               		.section	.progmem.data,"a",@progbits
 1386               	__c.3168:
 1387 0000 4661 696C 		.string	"Failed to open sensor driver\r\n"
 1387      6564 2074 
 1387      6F20 6F70 
 1387      656E 2073 
 1387      656E 736F 
 1390               	__c.3186:
 1391 001f 4661 696C 		.string	"Failed to open sensor driver\r\n"
 1391      6564 2074 
 1391      6F20 6F70 
 1391      656E 2073 
 1391      656E 736F 
 1394               	__c.3203:
 1395 003e 4661 696C 		.string	"Failed to load my ADC driver\r\n"
 1395      6564 2074 
 1395      6F20 6C6F 
 1395      6164 206D 
 1395      7920 4144 
 1411               		.text
 1413               	.Letext0:
 1414               		.ident	"GCC: (GNU) 4.7.2"
 1415               	.global __do_copy_data
 1416               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:4      *ABS*:000000000000003f __SREG__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:330    .text:0000000000000000 print_sensor_readings
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:1386   .progmem.data:0000000000000000 __c.3168
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:831    .text:0000000000000318 nrk_create_taskset
                            *COM*:0000000000000023 TaskOne
                            *COM*:0000000000000080 Stack1
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:1141   .text:000000000000050a collect_Audio_Data
                            *COM*:0000000000000023 TaskTwo
                            *COM*:0000000000000080 Stack2
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:1018   .text:000000000000046a calculate_rms
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:1390   .progmem.data:000000000000001f __c.3186
                            *COM*:0000000000000002 audio_data
                            *COM*:0000000000000001 audio_data_size
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:1268   .text:00000000000005b8 nrk_register_drivers
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:1394   .progmem.data:000000000000003e __c.3203
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccBcIuAP.s:1305   .text.startup:0000000000000000 main
                            *COM*:0000000000000001 app_timer0_prescale
                            *COM*:0000000000000002 app_timer0_callback
                            *COM*:0000000000000001 _nrk_time_trigger
                            *COM*:0000000000000001 _nrk_prev_timer_val
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000080 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
__udivdi3
__muldi3
printf
nrk_get_pid
nrk_open
nrk_kprintf
nrk_set_status
nrk_read
__ashldi3
__adddi3
__udivmodhi4
nrk_led_clr
putchar
puts
nrk_led_toggle
nrk_wait_until_next_period
nrk_task_set_stk
nrk_activate_task
nrk_task_set_entry_function
__floatunsisf
__fixunssfsi
__umulhisi3
__udivmodsi4
sqrt
nrk_spin_wait_us
dev_manager_ff3_sensors
nrk_register_driver
nrk_setup_ports
nrk_setup_uart
malloc
nrk_init
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
