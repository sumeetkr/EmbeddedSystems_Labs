   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 291               	.global	__floatunsisf
 292               		.section	.rodata.str1.1,"aMS",@progbits,1
 293               	.LC0:
 294 0000 7769 6E64 		.string	"window no =%d"
 294      6F77 206E 
 294      6F20 3D25 
 294      6400 
 295               	.global	__fixunssfsi
 296               	.LC1:
 297 000e 2068 6173 		.string	" has rms value =%d\r\n"
 297      2072 6D73 
 297      2076 616C 
 297      7565 203D 
 297      2564 0D0A 
 298               		.text
 303               	.global	calculate_rms
 305               	calculate_rms:
 306               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *  Contributing Authors (specific to this file):
  23:main.c        **** *  Zane Starr
  24:main.c        **** *******************************************************************************/
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** #include <nrk.h>
  28:main.c        **** #include <include.h>
  29:main.c        **** #include <ulib.h>
  30:main.c        **** #include <stdio.h>
  31:main.c        **** #include <avr/sleep.h>
  32:main.c        **** #include <hal.h>
  33:main.c        **** #include <nrk_error.h>
  34:main.c        **** #include <nrk_timer.h>
  35:main.c        **** #include <nrk_driver_list.h>
  36:main.c        **** #include <nrk_driver.h>
  37:main.c        **** #include <ff_basic_sensor.h>
  38:main.c        **** 
  39:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  40:main.c        **** nrk_task_type TaskOne;
  41:main.c        **** void Task_Observe_Noise_In_The_Room(void);
  42:main.c        **** uint16_t calculate_rms(uint16_t audios [], int8_t size, int8_t window_size);
  43:main.c        **** 
  44:main.c        **** 
  45:main.c        **** void nrk_create_taskset();
  46:main.c        **** void nrk_register_drivers();
  47:main.c        **** uint8_t kill_stack(uint8_t val);
  48:main.c        **** 
  49:main.c        **** int
  50:main.c        **** main ()
  51:main.c        **** {
  52:main.c        ****   uint8_t t;
  53:main.c        ****   nrk_setup_ports();
  54:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
  55:main.c        **** 
  56:main.c        **** 
  57:main.c        ****   printf( PSTR("starting...\r\n") );
  58:main.c        **** 
  59:main.c        ****   nrk_init();
  60:main.c        ****   nrk_time_set(0,0);
  61:main.c        **** 
  62:main.c        ****   nrk_register_drivers();
  63:main.c        ****   nrk_create_taskset ();
  64:main.c        ****   nrk_start();
  65:main.c        ****   
  66:main.c        ****   return 0;
  67:main.c        **** }
  68:main.c        **** 
  69:main.c        **** 
  70:main.c        **** void 
  71:main.c        **** Task_Observe_Noise_In_The_Room(){
  72:main.c        **** 
  73:main.c        **** int8_t fd, val, index;
  74:main.c        **** int8_t window_size = 10;
  75:main.c        **** uint16_t buf;
  76:main.c        **** uint16_t audio[20] = {0};
  77:main.c        **** int8_t size = sizeof(audio)/sizeof(audio[0]);
  78:main.c        **** 
  79:main.c        **** // Open ADC device as read 
  80:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
  81:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
  82:main.c        **** 
  83:main.c        **** 	while(1)
  84:main.c        **** 	{
  85:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO_P2P);
  86:main.c        **** 		nrk_spin_wait_us(60000);
  87:main.c        **** 		val=nrk_read(fd,&buf,2);
  88:main.c        **** 		printf( " audio=%d\r\n",buf);
  89:main.c        **** 
  90:main.c        **** 		audio[index] = buf;
  91:main.c        **** 		index++;
  92:main.c        **** 
  93:main.c        **** 		if(index == size)
  94:main.c        **** 		{
  95:main.c        **** 			// calculate and print rms
  96:main.c        **** 			uint16_t rms = calculate_rms(audio, size, window_size);
  97:main.c        **** 			index =0;
  98:main.c        **** 		}
  99:main.c        **** 
 100:main.c        **** 		nrk_wait_until_next_period();
 101:main.c        **** 	}
 102:main.c        **** }
 103:main.c        **** 
 104:main.c        **** uint16_t
 105:main.c        **** calculate_rms(uint16_t audios [], int8_t size, int8_t window_size)
 106:main.c        **** {
 308               	.LM0:
 309               	.LFBB1:
 310 0000 2F92      		push r2
 311 0002 3F92      		push r3
 312 0004 4F92      		push r4
 313 0006 5F92      		push r5
 314 0008 6F92      		push r6
 315 000a 7F92      		push r7
 316 000c 8F92      		push r8
 317 000e 9F92      		push r9
 318 0010 AF92      		push r10
 319 0012 BF92      		push r11
 320 0014 CF92      		push r12
 321 0016 DF92      		push r13
 322 0018 EF92      		push r14
 323 001a FF92      		push r15
 324 001c 0F93      		push r16
 325 001e 1F93      		push r17
 326 0020 CF93      		push r28
 327 0022 DF93      		push r29
 328 0024 1F92      		push __zero_reg__
 329 0026 CDB7      		in r28,__SP_L__
 330 0028 DEB7      		in r29,__SP_H__
 331               	/* prologue: function */
 332               	/* frame size = 1 */
 333               	/* stack size = 19 */
 334               	.L__stack_usage = 19
 335 002a 5C01      		movw r10,r24
 107:main.c        **** 	uint8_t index = 0;
 108:main.c        **** 	uint8_t window_count = 0;
 337               	.LM1:
 338 002c 812C      		mov r8,__zero_reg__
 107:main.c        **** 	uint8_t index = 0;
 340               	.LM2:
 341 002e 912C      		mov r9,__zero_reg__
 109:main.c        **** 
 110:main.c        **** 	while(index + window_size <= size)
 343               	.LM3:
 344 0030 E42E      		mov r14,r20
 345 0032 FF24      		clr r15
 346 0034 E7FC      		sbrc r14,7
 347 0036 F094      		com r15
 348 0038 C62E      		mov r12,r22
 349 003a DD24      		clr r13
 350 003c C7FC      		sbrc r12,7
 351 003e D094      		com r13
 352               	.LBB2:
 111:main.c        **** 	{
 112:main.c        **** 		uint16_t rawrms  =0;
 113:main.c        **** 		uint16_t rms  = 0;
 114:main.c        **** 
 115:main.c        **** 		for(uint8_t count = index ; count < index + window_size ; count++ )
 116:main.c        **** 		{
 117:main.c        **** 			rawrms += audios[count] * audios[count] ;
 118:main.c        **** 		}
 119:main.c        **** 
 120:main.c        **** 		rms = rawrms / window_size ;
 121:main.c        **** 		rms = sqrt(rms) ;
 122:main.c        **** 
 123:main.c        **** 		printf( "window no =%d", window_count);
 354               	.LM4:
 355 0040 70E0      		ldi r23,lo8(.LC0)
 356 0042 272E      		mov r2,r23
 357 0044 70E0      		ldi r23,hi8(.LC0)
 358 0046 372E      		mov r3,r23
 124:main.c        **** 		printf( " has rms value =%d\r\n",rms);
 360               	.LM5:
 361 0048 00E0      		ldi r16,lo8(.LC1)
 362 004a 10E0      		ldi r17,hi8(.LC1)
 363               	.LBE2:
 110:main.c        **** 	while(index + window_size <= size)
 365               	.LM6:
 366 004c 00C0      		rjmp .L2
 367               	.L3:
 368               	.LBB5:
 369               	.LBB3:
 117:main.c        **** 			rawrms += audios[count] * audios[count] ;
 371               	.LM7:
 372 004e EE0F      		lsl r30
 373 0050 FF1F      		rol r31
 374 0052 EA0D      		add r30,r10
 375 0054 FB1D      		adc r31,r11
 376 0056 6081      		ld r22,Z
 377 0058 7181      		ldd r23,Z+1
 378 005a 669F      		mul r22,r22
 379 005c F001      		movw r30,r0
 380 005e 679F      		mul r22,r23
 381 0060 F00D      		add r31,r0
 382 0062 F00D      		add r31,r0
 383 0064 1124      		clr r1
 384 0066 8E0F      		add r24,r30
 385 0068 9F1F      		adc r25,r31
 115:main.c        **** 		for(uint8_t count = index ; count < index + window_size ; count++ )
 387               	.LM8:
 388 006a 5F5F      		subi r21,lo8(-(1))
 389 006c 00C0      		rjmp .L4
 390               	.L5:
 391               	.LBE3:
 392               	.LBE5:
 110:main.c        **** 	while(index + window_size <= size)
 394               	.LM9:
 395 006e 592D      		mov r21,r9
 396 0070 80E0      		ldi r24,0
 397 0072 90E0      		ldi r25,0
 398               	.L4:
 399               	.LBB6:
 400               	.LBB4:
 115:main.c        **** 		for(uint8_t count = index ; count < index + window_size ; count++ )
 402               	.LM10:
 403 0074 E52F      		mov r30,r21
 404 0076 F0E0      		ldi r31,0
 405 0078 E217      		cp r30,r18
 406 007a F307      		cpc r31,r19
 407 007c 04F0      		brlt .L3
 408               	.LBE4:
 120:main.c        **** 		rms = rawrms / window_size ;
 410               	.LM11:
 411 007e B701      		movw r22,r14
 412 0080 0E94 0000 		call __udivmodhi4
 121:main.c        **** 		rms = sqrt(rms) ;
 414               	.LM12:
 415 0084 80E0      		ldi r24,0
 416 0086 90E0      		ldi r25,0
 417 0088 4983      		std Y+1,r20
 418 008a 0E94 0000 		call __floatunsisf
 419 008e 0E94 0000 		call sqrt
 420 0092 2B01      		movw r4,r22
 421 0094 3C01      		movw r6,r24
 123:main.c        **** 		printf( "window no =%d", window_count);
 423               	.LM13:
 424 0096 1F92      		push __zero_reg__
 425 0098 8F92      		push r8
 426 009a 3F92      		push r3
 427 009c 2F92      		push r2
 428 009e 0E94 0000 		call printf
 121:main.c        **** 		rms = sqrt(rms) ;
 430               	.LM14:
 431 00a2 C301      		movw r24,r6
 432 00a4 B201      		movw r22,r4
 433 00a6 0E94 0000 		call __fixunssfsi
 435               	.LM15:
 436 00aa 7F93      		push r23
 437 00ac 6F93      		push r22
 438 00ae 1F93      		push r17
 439 00b0 0F93      		push r16
 440 00b2 0E94 0000 		call printf
 125:main.c        **** 
 126:main.c        **** 		window_count++;
 442               	.LM16:
 443 00b6 8394      		inc r8
 105:main.c        **** calculate_rms(uint16_t audios [], int8_t size, int8_t window_size)
 445               	.LM17:
 446 00b8 4981      		ldd r20,Y+1
 447 00ba 940E      		add r9,r20
 448 00bc 0FB6      		in __tmp_reg__,__SREG__
 449 00be F894      		cli
 450 00c0 DEBF      		out __SP_H__,r29
 451 00c2 0FBE      		out __SREG__,__tmp_reg__
 452 00c4 CDBF      		out __SP_L__,r28
 453               	.L2:
 454               	.LBE6:
 110:main.c        **** 	while(index + window_size <= size)
 456               	.LM18:
 457 00c6 9701      		movw r18,r14
 458 00c8 290D      		add r18,r9
 459 00ca 311D      		adc r19,__zero_reg__
 460 00cc C216      		cp r12,r18
 461 00ce D306      		cpc r13,r19
 462 00d0 04F4      		brge .L5
 127:main.c        **** 		index = index + window_size;
 128:main.c        **** 	}
 129:main.c        **** 
 130:main.c        **** 	return 0;
 131:main.c        **** }
 464               	.LM19:
 465 00d2 80E0      		ldi r24,0
 466 00d4 90E0      		ldi r25,0
 467               	/* epilogue start */
 468 00d6 0F90      		pop __tmp_reg__
 469 00d8 DF91      		pop r29
 470 00da CF91      		pop r28
 471 00dc 1F91      		pop r17
 472 00de 0F91      		pop r16
 473 00e0 FF90      		pop r15
 474 00e2 EF90      		pop r14
 475 00e4 DF90      		pop r13
 476 00e6 CF90      		pop r12
 477 00e8 BF90      		pop r11
 478 00ea AF90      		pop r10
 479 00ec 9F90      		pop r9
 480 00ee 8F90      		pop r8
 481 00f0 7F90      		pop r7
 482 00f2 6F90      		pop r6
 483 00f4 5F90      		pop r5
 484 00f6 4F90      		pop r4
 485 00f8 3F90      		pop r3
 486 00fa 2F90      		pop r2
 487 00fc 0895      		ret
 508               	.Lscope1:
 510               		.stabd	78,0,0
 511               		.section	.rodata.str1.1
 512               	.LC2:
 513 0023 2061 7564 		.string	" audio=%d\r\n"
 513      696F 3D25 
 513      640D 0A00 
 514               		.text
 516               	.global	Task_Observe_Noise_In_The_Room
 518               	Task_Observe_Noise_In_The_Room:
 519               		.stabd	46,0,0
  71:main.c        **** Task_Observe_Noise_In_The_Room(){
 521               	.LM20:
 522               	.LFBB2:
 523 00fe CF93      		push r28
 524 0100 DF93      		push r29
 525 0102 CDB7      		in r28,__SP_L__
 526 0104 DEB7      		in r29,__SP_H__
 527 0106 AA97      		sbiw r28,42
 528 0108 0FB6      		in __tmp_reg__,__SREG__
 529 010a F894      		cli
 530 010c DEBF      		out __SP_H__,r29
 531 010e 0FBE      		out __SREG__,__tmp_reg__
 532 0110 CDBF      		out __SP_L__,r28
 533               	/* prologue: function */
 534               	/* frame size = 42 */
 535               	/* stack size = 44 */
 536               	.L__stack_usage = 44
  76:main.c        **** uint16_t audio[20] = {0};
 538               	.LM21:
 539 0112 FE01      		movw r30,r28
 540 0114 3196      		adiw r30,1
 541 0116 88E2      		ldi r24,lo8(40)
 542 0118 DF01      		movw r26,r30
 543               		0:
 544 011a 1D92      		st X+,__zero_reg__
 545 011c 8A95      		dec r24
 546 011e 01F4      		brne 0b
  80:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 548               	.LM22:
 549 0120 65E0      		ldi r22,lo8(5)
 550 0122 83E0      		ldi r24,lo8(3)
 551 0124 0E94 0000 		call nrk_open
 552 0128 E82E      		mov r14,r24
  81:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 554               	.LM23:
 555 012a BFEF      		ldi r27,lo8(-1)
 556 012c 8B13      		cpse r24,r27
 557 012e 00C0      		rjmp .L9
  81:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 559               	.LM24:
 560 0130 80E0      		ldi r24,lo8(__c.3158)
 561 0132 90E0      		ldi r25,hi8(__c.3158)
 562 0134 0E94 0000 		call nrk_kprintf
 563               	.L9:
  88:main.c        **** 		printf( " audio=%d\r\n",buf);
 565               	.LM25:
 566 0138 00E0      		ldi r16,lo8(.LC2)
 567 013a 10E0      		ldi r17,hi8(.LC2)
 568               	.L10:
  85:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO_P2P);
 570               	.LM26:
 571 013c 4CE0      		ldi r20,lo8(12)
 572 013e 61E0      		ldi r22,lo8(1)
 573 0140 8E2D      		mov r24,r14
 574 0142 0E94 0000 		call nrk_set_status
  86:main.c        **** 		nrk_spin_wait_us(60000);
 576               	.LM27:
 577 0146 80E6      		ldi r24,lo8(96)
 578 0148 9AEE      		ldi r25,lo8(-22)
 579 014a 0E94 0000 		call nrk_spin_wait_us
  87:main.c        **** 		val=nrk_read(fd,&buf,2);
 581               	.LM28:
 582 014e 42E0      		ldi r20,lo8(2)
 583 0150 BE01      		movw r22,r28
 584 0152 675D      		subi r22,-41
 585 0154 7F4F      		sbci r23,-1
 586 0156 8E2D      		mov r24,r14
 587 0158 0E94 0000 		call nrk_read
  88:main.c        **** 		printf( " audio=%d\r\n",buf);
 589               	.LM29:
 590 015c 8AA5      		ldd r24,Y+42
 591 015e 8F93      		push r24
 592 0160 89A5      		ldd r24,Y+41
 593 0162 8F93      		push r24
 594 0164 1F93      		push r17
 595 0166 0F93      		push r16
 596 0168 0E94 0000 		call printf
  90:main.c        **** 		audio[index] = buf;
 598               	.LM30:
 599 016c EF2D      		mov r30,r15
 600 016e EE0F      		lsl r30
 601 0170 FF0B      		sbc r31,r31
 602 0172 81E0      		ldi r24,lo8(1)
 603 0174 90E0      		ldi r25,0
 604 0176 8C0F      		add r24,r28
 605 0178 9D1F      		adc r25,r29
 606 017a E80F      		add r30,r24
 607 017c F91F      		adc r31,r25
 608 017e 29A5      		ldd r18,Y+41
 609 0180 3AA5      		ldd r19,Y+42
 610 0182 3183      		std Z+1,r19
 611 0184 2083      		st Z,r18
  91:main.c        **** 		index++;
 613               	.LM31:
 614 0186 F394      		inc r15
  93:main.c        **** 		if(index == size)
 616               	.LM32:
 617 0188 0F90      		pop __tmp_reg__
 618 018a 0F90      		pop __tmp_reg__
 619 018c 0F90      		pop __tmp_reg__
 620 018e 0F90      		pop __tmp_reg__
 621 0190 94E1      		ldi r25,lo8(20)
 622 0192 F912      		cpse r15,r25
 623 0194 00C0      		rjmp .L8
 624               	.LBB7:
  96:main.c        **** 			uint16_t rms = calculate_rms(audio, size, window_size);
 626               	.LM33:
 627 0196 4AE0      		ldi r20,lo8(10)
 628 0198 64E1      		ldi r22,lo8(20)
 629 019a CE01      		movw r24,r28
 630 019c 0196      		adiw r24,1
 631 019e 0E94 0000 		call calculate_rms
  97:main.c        **** 			index =0;
 633               	.LM34:
 634 01a2 F12C      		mov r15,__zero_reg__
 635               	.L8:
 636               	.LBE7:
 100:main.c        **** 		nrk_wait_until_next_period();
 638               	.LM35:
 639 01a4 0E94 0000 		call nrk_wait_until_next_period
 101:main.c        **** 	}
 641               	.LM36:
 642 01a8 00C0      		rjmp .L10
 650               	.Lscope2:
 652               		.stabd	78,0,0
 654               	.global	nrk_create_taskset
 656               	nrk_create_taskset:
 657               		.stabd	46,0,0
 132:main.c        **** 
 133:main.c        **** void
 134:main.c        **** nrk_create_taskset()
 135:main.c        **** {
 659               	.LM37:
 660               	.LFBB3:
 661               	/* prologue: function */
 662               	/* frame size = 0 */
 663               	/* stack size = 0 */
 664               	.L__stack_usage = 0
 136:main.c        ****   TaskOne.task = Task_Observe_Noise_In_The_Room;
 666               	.LM38:
 667 01aa 80E0      		ldi r24,lo8(gs(Task_Observe_Noise_In_The_Room))
 668 01ac 90E0      		ldi r25,hi8(gs(Task_Observe_Noise_In_The_Room))
 669 01ae 9093 0000 		sts TaskOne+5+1,r25
 670 01b2 8093 0000 		sts TaskOne+5,r24
 137:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
 672               	.LM39:
 673 01b6 40E8      		ldi r20,lo8(-128)
 674 01b8 50E0      		ldi r21,0
 675 01ba 60E0      		ldi r22,lo8(Stack1)
 676 01bc 70E0      		ldi r23,hi8(Stack1)
 677 01be 80E0      		ldi r24,lo8(TaskOne)
 678 01c0 90E0      		ldi r25,hi8(TaskOne)
 679 01c2 0E94 0000 		call nrk_task_set_stk
 138:main.c        ****   TaskOne.prio = 1;
 681               	.LM40:
 682 01c6 81E0      		ldi r24,lo8(1)
 683 01c8 8093 0000 		sts TaskOne+8,r24
 139:main.c        ****   TaskOne.FirstActivation = TRUE;
 685               	.LM41:
 686 01cc 8093 0000 		sts TaskOne+7,r24
 140:main.c        ****   TaskOne.Type = BASIC_TASK;
 688               	.LM42:
 689 01d0 8093 0000 		sts TaskOne+9,r24
 141:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 691               	.LM43:
 692 01d4 8093 0000 		sts TaskOne+10,r24
 142:main.c        ****   TaskOne.period.secs = 0;
 694               	.LM44:
 695 01d8 1092 0000 		sts TaskOne+11,__zero_reg__
 696 01dc 1092 0000 		sts TaskOne+11+1,__zero_reg__
 697 01e0 1092 0000 		sts TaskOne+11+2,__zero_reg__
 698 01e4 1092 0000 		sts TaskOne+11+3,__zero_reg__
 143:main.c        ****   TaskOne.period.nano_secs = 500*NANOS_PER_MS; //*NANOS_PER_MS;
 700               	.LM45:
 701 01e8 80E0      		ldi r24,0
 702 01ea 95E6      		ldi r25,lo8(101)
 703 01ec ADEC      		ldi r26,lo8(-51)
 704 01ee BDE1      		ldi r27,lo8(29)
 705 01f0 8093 0000 		sts TaskOne+15,r24
 706 01f4 9093 0000 		sts TaskOne+15+1,r25
 707 01f8 A093 0000 		sts TaskOne+15+2,r26
 708 01fc B093 0000 		sts TaskOne+15+3,r27
 144:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 710               	.LM46:
 711 0200 1092 0000 		sts TaskOne+19,__zero_reg__
 712 0204 1092 0000 		sts TaskOne+19+1,__zero_reg__
 713 0208 1092 0000 		sts TaskOne+19+2,__zero_reg__
 714 020c 1092 0000 		sts TaskOne+19+3,__zero_reg__
 145:main.c        ****   TaskOne.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 716               	.LM47:
 717 0210 80E0      		ldi r24,0
 718 0212 91EE      		ldi r25,lo8(-31)
 719 0214 A5EF      		ldi r26,lo8(-11)
 720 0216 B5E0      		ldi r27,lo8(5)
 721 0218 8093 0000 		sts TaskOne+23,r24
 722 021c 9093 0000 		sts TaskOne+23+1,r25
 723 0220 A093 0000 		sts TaskOne+23+2,r26
 724 0224 B093 0000 		sts TaskOne+23+3,r27
 146:main.c        ****   TaskOne.offset.secs = 0;
 726               	.LM48:
 727 0228 1092 0000 		sts TaskOne+27,__zero_reg__
 728 022c 1092 0000 		sts TaskOne+27+1,__zero_reg__
 729 0230 1092 0000 		sts TaskOne+27+2,__zero_reg__
 730 0234 1092 0000 		sts TaskOne+27+3,__zero_reg__
 147:main.c        ****   TaskOne.offset.nano_secs= 0;
 732               	.LM49:
 733 0238 1092 0000 		sts TaskOne+31,__zero_reg__
 734 023c 1092 0000 		sts TaskOne+31+1,__zero_reg__
 735 0240 1092 0000 		sts TaskOne+31+2,__zero_reg__
 736 0244 1092 0000 		sts TaskOne+31+3,__zero_reg__
 148:main.c        ****   nrk_activate_task (&TaskOne);
 738               	.LM50:
 739 0248 80E0      		ldi r24,lo8(TaskOne)
 740 024a 90E0      		ldi r25,hi8(TaskOne)
 741 024c 0C94 0000 		jmp nrk_activate_task
 743               	.Lscope3:
 745               		.stabd	78,0,0
 747               	.global	nrk_register_drivers
 749               	nrk_register_drivers:
 750               		.stabd	46,0,0
 149:main.c        **** 
 150:main.c        **** }
 151:main.c        **** 
 152:main.c        **** void nrk_register_drivers()
 153:main.c        **** {
 752               	.LM51:
 753               	.LFBB4:
 754               	/* prologue: function */
 755               	/* frame size = 0 */
 756               	/* stack size = 0 */
 757               	.L__stack_usage = 0
 154:main.c        **** int8_t val;
 155:main.c        **** 
 156:main.c        **** // Register the Basic FireFly Sensor device driver
 157:main.c        **** // Make sure to add: 
 158:main.c        **** //     #define NRK_MAX_DRIVER_CNT  
 159:main.c        **** //     in nrk_cfg.h
 160:main.c        **** // Make sure to add: 
 161:main.c        **** //     SRC += $(ROOT_DIR)/src/drivers/platform/$(PLATFORM_TYPE)/source/ff_basic_sensor.c
 162:main.c        **** //     in makefile
 163:main.c        **** val=nrk_register_driver( &dev_manager_ff3_sensors,FIREFLY_3_SENSOR_BASIC);
 759               	.LM52:
 760 0250 63E0      		ldi r22,lo8(3)
 761 0252 80E0      		ldi r24,lo8(gs(dev_manager_ff3_sensors))
 762 0254 90E0      		ldi r25,hi8(gs(dev_manager_ff3_sensors))
 763 0256 0E94 0000 		call nrk_register_driver
 164:main.c        **** if(val==NRK_ERROR) nrk_kprintf( PSTR("Failed to load my ADC driver\r\n") );
 765               	.LM53:
 766 025a 8F3F      		cpi r24,lo8(-1)
 767 025c 01F4      		brne .L12
 769               	.LM54:
 770 025e 80E0      		ldi r24,lo8(__c.3184)
 771 0260 90E0      		ldi r25,hi8(__c.3184)
 772 0262 0C94 0000 		jmp nrk_kprintf
 773               	.L12:
 774 0266 0895      		ret
 776               	.Lscope4:
 778               		.stabd	78,0,0
 779               		.section	.rodata.str1.1
 780               	.LC3:
 781 002f 7374 6172 		.string	"starting...\r"
 781      7469 6E67 
 781      2E2E 2E0D 
 781      00
 782               		.section	.text.startup,"ax",@progbits
 784               	.global	main
 786               	main:
 787               		.stabd	46,0,0
  51:main.c        **** {
 789               	.LM55:
 790               	.LFBB5:
 791               	/* prologue: function */
 792               	/* frame size = 0 */
 793               	/* stack size = 0 */
 794               	.L__stack_usage = 0
  53:main.c        ****   nrk_setup_ports();
 796               	.LM56:
 797 0000 0E94 0000 		call nrk_setup_ports
  54:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 799               	.LM57:
 800 0004 80E1      		ldi r24,lo8(16)
 801 0006 90E0      		ldi r25,0
 802 0008 0E94 0000 		call nrk_setup_uart
  57:main.c        ****   printf( PSTR("starting...\r\n") );
 804               	.LM58:
 805 000c 80E0      		ldi r24,lo8(.LC3)
 806 000e 90E0      		ldi r25,hi8(.LC3)
 807 0010 0E94 0000 		call puts
  59:main.c        ****   nrk_init();
 809               	.LM59:
 810 0014 0E94 0000 		call nrk_init
  60:main.c        ****   nrk_time_set(0,0);
 812               	.LM60:
 813 0018 20E0      		ldi r18,0
 814 001a 30E0      		ldi r19,0
 815 001c A901      		movw r20,r18
 816 001e 60E0      		ldi r22,0
 817 0020 70E0      		ldi r23,0
 818 0022 CB01      		movw r24,r22
 819 0024 0E94 0000 		call nrk_time_set
  62:main.c        ****   nrk_register_drivers();
 821               	.LM61:
 822 0028 0E94 0000 		call nrk_register_drivers
  63:main.c        ****   nrk_create_taskset ();
 824               	.LM62:
 825 002c 0E94 0000 		call nrk_create_taskset
  64:main.c        ****   nrk_start();
 827               	.LM63:
 828 0030 0E94 0000 		call nrk_start
  67:main.c        **** }
 830               	.LM64:
 831 0034 80E0      		ldi r24,0
 832 0036 90E0      		ldi r25,0
 833 0038 0895      		ret
 835               	.Lscope5:
 837               		.stabd	78,0,0
 838               		.comm	TaskOne,35,1
 839               		.comm	Stack1,128,1
 840               		.comm	app_timer0_prescale,1,1
 841               		.comm	app_timer0_callback,2,1
 842               		.comm	_nrk_time_trigger,1,1
 843               		.comm	_nrk_prev_timer_val,1,1
 844               		.comm	error_num,1,1
 845               		.comm	error_task,1,1
 846               		.comm	nrk_kernel_stk_ptr,2,1
 847               		.comm	nrk_idle_task_stk,128,1
 848               		.comm	_nrk_signal_list,4,1
 849               		.section	.progmem.data,"a",@progbits
 852               	__c.3158:
 853 0000 4661 696C 		.string	"Failed to open sensor driver\r\n"
 853      6564 2074 
 853      6F20 6F70 
 853      656E 2073 
 853      656E 736F 
 856               	__c.3184:
 857 001f 4661 696C 		.string	"Failed to load my ADC driver\r\n"
 857      6564 2074 
 857      6F20 6C6F 
 857      6164 206D 
 857      7920 4144 
 869               		.text
 871               	.Letext0:
 872               		.ident	"GCC: (GNU) 4.7.2"
 873               	.global __do_copy_data
 874               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:4      *ABS*:000000000000003f __SREG__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:305    .text:0000000000000000 calculate_rms
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:518    .text:00000000000000fe Task_Observe_Noise_In_The_Room
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:852    .progmem.data:0000000000000000 __c.3158
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:656    .text:00000000000001aa nrk_create_taskset
                            *COM*:0000000000000023 TaskOne
                            *COM*:0000000000000080 Stack1
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:749    .text:0000000000000250 nrk_register_drivers
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:856    .progmem.data:000000000000001f __c.3184
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cczbaNZX.s:786    .text.startup:0000000000000000 main
                            *COM*:0000000000000001 app_timer0_prescale
                            *COM*:0000000000000002 app_timer0_callback
                            *COM*:0000000000000001 _nrk_time_trigger
                            *COM*:0000000000000001 _nrk_prev_timer_val
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000080 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
__floatunsisf
__fixunssfsi
__udivmodhi4
sqrt
printf
nrk_open
nrk_kprintf
nrk_set_status
nrk_spin_wait_us
nrk_read
nrk_wait_until_next_period
nrk_task_set_stk
nrk_activate_task
dev_manager_ff3_sensors
nrk_register_driver
nrk_setup_ports
nrk_setup_uart
puts
nrk_init
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
