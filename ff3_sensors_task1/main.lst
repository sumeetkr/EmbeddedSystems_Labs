   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 291               	.global	__floatunsisf
 292               	.global	__fixunssfsi
 296               	.global	calculate_rms
 298               	calculate_rms:
 299               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *  Contributing Authors (specific to this file):
  23:main.c        **** *  Zane Starr
  24:main.c        **** *******************************************************************************/
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** #include <nrk.h>
  28:main.c        **** #include <include.h>
  29:main.c        **** #include <ulib.h>
  30:main.c        **** #include <stdio.h>
  31:main.c        **** #include <avr/sleep.h>
  32:main.c        **** #include <hal.h>
  33:main.c        **** #include <nrk_error.h>
  34:main.c        **** #include <nrk_timer.h>
  35:main.c        **** #include <nrk_driver_list.h>
  36:main.c        **** #include <nrk_driver.h>
  37:main.c        **** #include <ff_basic_sensor.h>
  38:main.c        **** 
  39:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  40:main.c        **** nrk_task_type TaskOne;
  41:main.c        **** void Task_Observe_Noise_In_The_Room(void);
  42:main.c        **** uint16_t calculate_rms(uint16_t audios [], int8_t window_size);
  43:main.c        **** 
  44:main.c        **** 
  45:main.c        **** void nrk_create_taskset();
  46:main.c        **** void nrk_register_drivers();
  47:main.c        **** uint8_t kill_stack(uint8_t val);
  48:main.c        **** 
  49:main.c        **** int
  50:main.c        **** main ()
  51:main.c        **** {
  52:main.c        ****   uint8_t t;
  53:main.c        ****   nrk_setup_ports();
  54:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
  55:main.c        **** 
  56:main.c        **** 
  57:main.c        ****   printf( PSTR("starting...\r\n") );
  58:main.c        **** 
  59:main.c        ****   nrk_init();
  60:main.c        ****   nrk_time_set(0,0);
  61:main.c        **** 
  62:main.c        ****   nrk_register_drivers();
  63:main.c        ****   nrk_create_taskset ();
  64:main.c        ****   nrk_start();
  65:main.c        ****   
  66:main.c        ****   return 0;
  67:main.c        **** }
  68:main.c        **** 
  69:main.c        **** 
  70:main.c        **** void 
  71:main.c        **** Task_Observe_Noise_In_The_Room(){
  72:main.c        **** 
  73:main.c        **** int8_t fd, val, index;
  74:main.c        **** uint16_t buf;
  75:main.c        **** uint16_t audio[10] = {0};
  76:main.c        **** int8_t size = sizeof(audio)/sizeof(audio[0]);
  77:main.c        **** 
  78:main.c        **** // Open ADC device as read 
  79:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
  80:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
  81:main.c        **** 
  82:main.c        **** 	while(1)
  83:main.c        **** 	{
  84:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO_P2P);
  85:main.c        **** 		nrk_spin_wait_us(60000);
  86:main.c        **** 		val=nrk_read(fd,&buf,2);
  87:main.c        **** 		// printf( " audio=%d\r\n",buf);
  88:main.c        **** 		nrk_wait_until_next_period();
  89:main.c        **** 
  90:main.c        **** 		audio[index] = buf;
  91:main.c        **** 		index++;
  92:main.c        **** 
  93:main.c        **** 		if(index == size)
  94:main.c        **** 		{
  95:main.c        **** 			// calculate and print rms
  96:main.c        **** 			uint16_t rms = calculate_rms(audio, size);
  97:main.c        **** 			printf( " calculate_rms=%d\r\n",rms);
  98:main.c        **** 			index =0;
  99:main.c        **** 		}
 100:main.c        **** 	}
 101:main.c        **** }
 102:main.c        **** 
 103:main.c        **** uint16_t
 104:main.c        **** calculate_rms(uint16_t audios [], int8_t window_size)
 105:main.c        **** {
 301               	.LM0:
 302               	.LFBB1:
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 0 */
 306               	.L__stack_usage = 0
 307               	.LBB2:
 106:main.c        **** 	uint16_t rawrms ;
 107:main.c        **** 	uint16_t rms ;
 108:main.c        **** 
 109:main.c        **** 	for(uint8_t count = 0 ; count < window_size ; count++ )
 309               	.LM1:
 310 0000 A0E0      		ldi r26,0
 311 0002 7727      		clr r23
 312 0004 67FD      		sbrc r22,7
 313 0006 7095      		com r23
 314 0008 00C0      		rjmp .L2
 315               	.L3:
 110:main.c        **** 	{
 111:main.c        **** 		rawrms += audios[count] * audios[count] ;
 317               	.LM2:
 318 000a EE0F      		lsl r30
 319 000c FF1F      		rol r31
 320 000e E80F      		add r30,r24
 321 0010 F91F      		adc r31,r25
 322 0012 4081      		ld r20,Z
 323 0014 5181      		ldd r21,Z+1
 324 0016 449F      		mul r20,r20
 325 0018 F001      		movw r30,r0
 326 001a 459F      		mul r20,r21
 327 001c F00D      		add r31,r0
 328 001e F00D      		add r31,r0
 329 0020 1124      		clr r1
 330 0022 2E0F      		add r18,r30
 331 0024 3F1F      		adc r19,r31
 109:main.c        **** 	for(uint8_t count = 0 ; count < window_size ; count++ )
 333               	.LM3:
 334 0026 AF5F      		subi r26,lo8(-(1))
 335               	.L2:
 109:main.c        **** 	for(uint8_t count = 0 ; count < window_size ; count++ )
 337               	.LM4:
 338 0028 EA2F      		mov r30,r26
 339 002a F0E0      		ldi r31,0
 340 002c E617      		cp r30,r22
 341 002e F707      		cpc r31,r23
 342 0030 04F0      		brlt .L3
 343               	.LBE2:
 112:main.c        **** 	}
 113:main.c        **** 
 114:main.c        **** 	rms = rawrms / window_size ;
 345               	.LM5:
 346 0032 C901      		movw r24,r18
 347 0034 0E94 0000 		call __udivmodhi4
 115:main.c        **** 	rms = sqrt(rms) ;
 349               	.LM6:
 350 0038 80E0      		ldi r24,0
 351 003a 90E0      		ldi r25,0
 352 003c 0E94 0000 		call __floatunsisf
 353 0040 0E94 0000 		call sqrt
 354 0044 0E94 0000 		call __fixunssfsi
 116:main.c        **** 
 117:main.c        **** 	return rms;
 118:main.c        **** }
 356               	.LM7:
 357 0048 CB01      		movw r24,r22
 358 004a 0895      		ret
 366               	.Lscope1:
 368               		.stabd	78,0,0
 369               		.section	.rodata.str1.1,"aMS",@progbits,1
 370               	.LC0:
 371 0000 2063 616C 		.string	" calculate_rms=%d\r\n"
 371      6375 6C61 
 371      7465 5F72 
 371      6D73 3D25 
 371      640D 0A00 
 372               		.text
 374               	.global	Task_Observe_Noise_In_The_Room
 376               	Task_Observe_Noise_In_The_Room:
 377               		.stabd	46,0,0
  71:main.c        **** Task_Observe_Noise_In_The_Room(){
 379               	.LM8:
 380               	.LFBB2:
 381 004c CF93      		push r28
 382 004e DF93      		push r29
 383 0050 CDB7      		in r28,__SP_L__
 384 0052 DEB7      		in r29,__SP_H__
 385 0054 6697      		sbiw r28,22
 386 0056 0FB6      		in __tmp_reg__,__SREG__
 387 0058 F894      		cli
 388 005a DEBF      		out __SP_H__,r29
 389 005c 0FBE      		out __SREG__,__tmp_reg__
 390 005e CDBF      		out __SP_L__,r28
 391               	/* prologue: function */
 392               	/* frame size = 22 */
 393               	/* stack size = 24 */
 394               	.L__stack_usage = 24
  75:main.c        **** uint16_t audio[10] = {0};
 396               	.LM9:
 397 0060 FE01      		movw r30,r28
 398 0062 3196      		adiw r30,1
 399 0064 84E1      		ldi r24,lo8(20)
 400 0066 DF01      		movw r26,r30
 401               		0:
 402 0068 1D92      		st X+,__zero_reg__
 403 006a 8A95      		dec r24
 404 006c 01F4      		brne 0b
  79:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 406               	.LM10:
 407 006e 65E0      		ldi r22,lo8(5)
 408 0070 83E0      		ldi r24,lo8(3)
 409 0072 0E94 0000 		call nrk_open
 410 0076 B82E      		mov r11,r24
  80:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 412               	.LM11:
 413 0078 BFEF      		ldi r27,lo8(-1)
 414 007a 8B13      		cpse r24,r27
 415 007c 00C0      		rjmp .L7
  80:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 417               	.LM12:
 418 007e 80E0      		ldi r24,lo8(__c.3156)
 419 0080 90E0      		ldi r25,hi8(__c.3156)
 420 0082 0E94 0000 		call nrk_kprintf
 421               	.L7:
  71:main.c        **** Task_Observe_Noise_In_The_Room(){
 423               	.LM13:
 424 0086 6E01      		movw r12,r28
 425 0088 E5E1      		ldi r30,21
 426 008a CE0E      		add r12,r30
 427 008c D11C      		adc r13,__zero_reg__
 428               	.LBB3:
  97:main.c        **** 			printf( " calculate_rms=%d\r\n",rms);
 430               	.LM14:
 431 008e 50E0      		ldi r21,lo8(.LC0)
 432 0090 E52E      		mov r14,r21
 433 0092 50E0      		ldi r21,hi8(.LC0)
 434 0094 F52E      		mov r15,r21
 435               	.L9:
 436 0096 8E01      		movw r16,r28
 437 0098 0F5F      		subi r16,-1
 438 009a 1F4F      		sbci r17,-1
 439               	.L6:
 440               	.LBE3:
  84:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO_P2P);
 442               	.LM15:
 443 009c 4CE0      		ldi r20,lo8(12)
 444 009e 61E0      		ldi r22,lo8(1)
 445 00a0 8B2D      		mov r24,r11
 446 00a2 0E94 0000 		call nrk_set_status
  85:main.c        **** 		nrk_spin_wait_us(60000);
 448               	.LM16:
 449 00a6 80E6      		ldi r24,lo8(96)
 450 00a8 9AEE      		ldi r25,lo8(-22)
 451 00aa 0E94 0000 		call nrk_spin_wait_us
  86:main.c        **** 		val=nrk_read(fd,&buf,2);
 453               	.LM17:
 454 00ae 42E0      		ldi r20,lo8(2)
 455 00b0 B601      		movw r22,r12
 456 00b2 8B2D      		mov r24,r11
 457 00b4 0E94 0000 		call nrk_read
  88:main.c        **** 		nrk_wait_until_next_period();
 459               	.LM18:
 460 00b8 0E94 0000 		call nrk_wait_until_next_period
  90:main.c        **** 		audio[index] = buf;
 462               	.LM19:
 463 00bc 2D89      		ldd r18,Y+21
 464 00be 3E89      		ldd r19,Y+22
 465 00c0 D801      		movw r26,r16
 466 00c2 2D93      		st X+,r18
 467 00c4 3D93      		st X+,r19
 468 00c6 8D01      		movw r16,r26
  93:main.c        **** 		if(index == size)
 470               	.LM20:
 471 00c8 AC15      		cp r26,r12
 472 00ca BD05      		cpc r27,r13
 473 00cc 01F4      		brne .L6
 474               	.LBB4:
  96:main.c        **** 			uint16_t rms = calculate_rms(audio, size);
 476               	.LM21:
 477 00ce 6AE0      		ldi r22,lo8(10)
 478 00d0 CE01      		movw r24,r28
 479 00d2 0196      		adiw r24,1
 480 00d4 0E94 0000 		call calculate_rms
  97:main.c        **** 			printf( " calculate_rms=%d\r\n",rms);
 482               	.LM22:
 483 00d8 9F93      		push r25
 484 00da 8F93      		push r24
 485 00dc FF92      		push r15
 486 00de EF92      		push r14
 487 00e0 0E94 0000 		call printf
 488 00e4 0F90      		pop __tmp_reg__
 489 00e6 0F90      		pop __tmp_reg__
 490 00e8 0F90      		pop __tmp_reg__
 491 00ea 0F90      		pop __tmp_reg__
 492 00ec 00C0      		rjmp .L9
 493               	.LBE4:
 500               	.Lscope2:
 502               		.stabd	78,0,0
 504               	.global	nrk_create_taskset
 506               	nrk_create_taskset:
 507               		.stabd	46,0,0
 119:main.c        **** 
 120:main.c        **** void
 121:main.c        **** nrk_create_taskset()
 122:main.c        **** {
 509               	.LM23:
 510               	.LFBB3:
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 0 */
 514               	.L__stack_usage = 0
 123:main.c        ****   TaskOne.task = Task_Observe_Noise_In_The_Room;
 516               	.LM24:
 517 00ee 80E0      		ldi r24,lo8(gs(Task_Observe_Noise_In_The_Room))
 518 00f0 90E0      		ldi r25,hi8(gs(Task_Observe_Noise_In_The_Room))
 519 00f2 9093 0000 		sts TaskOne+5+1,r25
 520 00f6 8093 0000 		sts TaskOne+5,r24
 124:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
 522               	.LM25:
 523 00fa 40E8      		ldi r20,lo8(-128)
 524 00fc 50E0      		ldi r21,0
 525 00fe 60E0      		ldi r22,lo8(Stack1)
 526 0100 70E0      		ldi r23,hi8(Stack1)
 527 0102 80E0      		ldi r24,lo8(TaskOne)
 528 0104 90E0      		ldi r25,hi8(TaskOne)
 529 0106 0E94 0000 		call nrk_task_set_stk
 125:main.c        ****   TaskOne.prio = 1;
 531               	.LM26:
 532 010a 81E0      		ldi r24,lo8(1)
 533 010c 8093 0000 		sts TaskOne+8,r24
 126:main.c        ****   TaskOne.FirstActivation = TRUE;
 535               	.LM27:
 536 0110 8093 0000 		sts TaskOne+7,r24
 127:main.c        ****   TaskOne.Type = BASIC_TASK;
 538               	.LM28:
 539 0114 8093 0000 		sts TaskOne+9,r24
 128:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 541               	.LM29:
 542 0118 8093 0000 		sts TaskOne+10,r24
 129:main.c        ****   TaskOne.period.secs = 0;
 544               	.LM30:
 545 011c 1092 0000 		sts TaskOne+11,__zero_reg__
 546 0120 1092 0000 		sts TaskOne+11+1,__zero_reg__
 547 0124 1092 0000 		sts TaskOne+11+2,__zero_reg__
 548 0128 1092 0000 		sts TaskOne+11+3,__zero_reg__
 130:main.c        ****   TaskOne.period.nano_secs = 20*NANOS_PER_MS; //*NANOS_PER_MS;
 550               	.LM31:
 551 012c 80E0      		ldi r24,0
 552 012e 9DE2      		ldi r25,lo8(45)
 553 0130 A1E3      		ldi r26,lo8(49)
 554 0132 B1E0      		ldi r27,lo8(1)
 555 0134 8093 0000 		sts TaskOne+15,r24
 556 0138 9093 0000 		sts TaskOne+15+1,r25
 557 013c A093 0000 		sts TaskOne+15+2,r26
 558 0140 B093 0000 		sts TaskOne+15+3,r27
 131:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 560               	.LM32:
 561 0144 1092 0000 		sts TaskOne+19,__zero_reg__
 562 0148 1092 0000 		sts TaskOne+19+1,__zero_reg__
 563 014c 1092 0000 		sts TaskOne+19+2,__zero_reg__
 564 0150 1092 0000 		sts TaskOne+19+3,__zero_reg__
 132:main.c        ****   TaskOne.cpu_reserve.nano_secs =  100*NANOS_PER_MS;
 566               	.LM33:
 567 0154 80E0      		ldi r24,0
 568 0156 91EE      		ldi r25,lo8(-31)
 569 0158 A5EF      		ldi r26,lo8(-11)
 570 015a B5E0      		ldi r27,lo8(5)
 571 015c 8093 0000 		sts TaskOne+23,r24
 572 0160 9093 0000 		sts TaskOne+23+1,r25
 573 0164 A093 0000 		sts TaskOne+23+2,r26
 574 0168 B093 0000 		sts TaskOne+23+3,r27
 133:main.c        ****   TaskOne.offset.secs = 0;
 576               	.LM34:
 577 016c 1092 0000 		sts TaskOne+27,__zero_reg__
 578 0170 1092 0000 		sts TaskOne+27+1,__zero_reg__
 579 0174 1092 0000 		sts TaskOne+27+2,__zero_reg__
 580 0178 1092 0000 		sts TaskOne+27+3,__zero_reg__
 134:main.c        ****   TaskOne.offset.nano_secs= 0;
 582               	.LM35:
 583 017c 1092 0000 		sts TaskOne+31,__zero_reg__
 584 0180 1092 0000 		sts TaskOne+31+1,__zero_reg__
 585 0184 1092 0000 		sts TaskOne+31+2,__zero_reg__
 586 0188 1092 0000 		sts TaskOne+31+3,__zero_reg__
 135:main.c        ****   nrk_activate_task (&TaskOne);
 588               	.LM36:
 589 018c 80E0      		ldi r24,lo8(TaskOne)
 590 018e 90E0      		ldi r25,hi8(TaskOne)
 591 0190 0C94 0000 		jmp nrk_activate_task
 593               	.Lscope3:
 595               		.stabd	78,0,0
 597               	.global	nrk_register_drivers
 599               	nrk_register_drivers:
 600               		.stabd	46,0,0
 136:main.c        **** 
 137:main.c        **** }
 138:main.c        **** 
 139:main.c        **** void nrk_register_drivers()
 140:main.c        **** {
 602               	.LM37:
 603               	.LFBB4:
 604               	/* prologue: function */
 605               	/* frame size = 0 */
 606               	/* stack size = 0 */
 607               	.L__stack_usage = 0
 141:main.c        **** int8_t val;
 142:main.c        **** 
 143:main.c        **** // Register the Basic FireFly Sensor device driver
 144:main.c        **** // Make sure to add: 
 145:main.c        **** //     #define NRK_MAX_DRIVER_CNT  
 146:main.c        **** //     in nrk_cfg.h
 147:main.c        **** // Make sure to add: 
 148:main.c        **** //     SRC += $(ROOT_DIR)/src/drivers/platform/$(PLATFORM_TYPE)/source/ff_basic_sensor.c
 149:main.c        **** //     in makefile
 150:main.c        **** val=nrk_register_driver( &dev_manager_ff3_sensors,FIREFLY_3_SENSOR_BASIC);
 609               	.LM38:
 610 0194 63E0      		ldi r22,lo8(3)
 611 0196 80E0      		ldi r24,lo8(gs(dev_manager_ff3_sensors))
 612 0198 90E0      		ldi r25,hi8(gs(dev_manager_ff3_sensors))
 613 019a 0E94 0000 		call nrk_register_driver
 151:main.c        **** if(val==NRK_ERROR) nrk_kprintf( PSTR("Failed to load my ADC driver\r\n") );
 615               	.LM39:
 616 019e 8F3F      		cpi r24,lo8(-1)
 617 01a0 01F4      		brne .L11
 619               	.LM40:
 620 01a2 80E0      		ldi r24,lo8(__c.3176)
 621 01a4 90E0      		ldi r25,hi8(__c.3176)
 622 01a6 0C94 0000 		jmp nrk_kprintf
 623               	.L11:
 624 01aa 0895      		ret
 626               	.Lscope4:
 628               		.stabd	78,0,0
 629               		.section	.rodata.str1.1
 630               	.LC1:
 631 0014 7374 6172 		.string	"starting...\r"
 631      7469 6E67 
 631      2E2E 2E0D 
 631      00
 632               		.section	.text.startup,"ax",@progbits
 634               	.global	main
 636               	main:
 637               		.stabd	46,0,0
  51:main.c        **** {
 639               	.LM41:
 640               	.LFBB5:
 641               	/* prologue: function */
 642               	/* frame size = 0 */
 643               	/* stack size = 0 */
 644               	.L__stack_usage = 0
  53:main.c        ****   nrk_setup_ports();
 646               	.LM42:
 647 0000 0E94 0000 		call nrk_setup_ports
  54:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 649               	.LM43:
 650 0004 80E1      		ldi r24,lo8(16)
 651 0006 90E0      		ldi r25,0
 652 0008 0E94 0000 		call nrk_setup_uart
  57:main.c        ****   printf( PSTR("starting...\r\n") );
 654               	.LM44:
 655 000c 80E0      		ldi r24,lo8(.LC1)
 656 000e 90E0      		ldi r25,hi8(.LC1)
 657 0010 0E94 0000 		call puts
  59:main.c        ****   nrk_init();
 659               	.LM45:
 660 0014 0E94 0000 		call nrk_init
  60:main.c        ****   nrk_time_set(0,0);
 662               	.LM46:
 663 0018 20E0      		ldi r18,0
 664 001a 30E0      		ldi r19,0
 665 001c A901      		movw r20,r18
 666 001e 60E0      		ldi r22,0
 667 0020 70E0      		ldi r23,0
 668 0022 CB01      		movw r24,r22
 669 0024 0E94 0000 		call nrk_time_set
  62:main.c        ****   nrk_register_drivers();
 671               	.LM47:
 672 0028 0E94 0000 		call nrk_register_drivers
  63:main.c        ****   nrk_create_taskset ();
 674               	.LM48:
 675 002c 0E94 0000 		call nrk_create_taskset
  64:main.c        ****   nrk_start();
 677               	.LM49:
 678 0030 0E94 0000 		call nrk_start
  67:main.c        **** }
 680               	.LM50:
 681 0034 80E0      		ldi r24,0
 682 0036 90E0      		ldi r25,0
 683 0038 0895      		ret
 685               	.Lscope5:
 687               		.stabd	78,0,0
 688               		.comm	TaskOne,35,1
 689               		.comm	Stack1,128,1
 690               		.comm	app_timer0_prescale,1,1
 691               		.comm	app_timer0_callback,2,1
 692               		.comm	_nrk_time_trigger,1,1
 693               		.comm	_nrk_prev_timer_val,1,1
 694               		.comm	error_num,1,1
 695               		.comm	error_task,1,1
 696               		.comm	nrk_kernel_stk_ptr,2,1
 697               		.comm	nrk_idle_task_stk,128,1
 698               		.comm	_nrk_signal_list,4,1
 699               		.section	.progmem.data,"a",@progbits
 702               	__c.3156:
 703 0000 4661 696C 		.string	"Failed to open sensor driver\r\n"
 703      6564 2074 
 703      6F20 6F70 
 703      656E 2073 
 703      656E 736F 
 706               	__c.3176:
 707 001f 4661 696C 		.string	"Failed to load my ADC driver\r\n"
 707      6564 2074 
 707      6F20 6C6F 
 707      6164 206D 
 707      7920 4144 
 719               		.text
 721               	.Letext0:
 722               		.ident	"GCC: (GNU) 4.7.2"
 723               	.global __do_copy_data
 724               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:4      *ABS*:000000000000003f __SREG__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:298    .text:0000000000000000 calculate_rms
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:376    .text:000000000000004c Task_Observe_Noise_In_The_Room
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:702    .progmem.data:0000000000000000 __c.3156
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:506    .text:00000000000000ee nrk_create_taskset
                            *COM*:0000000000000023 TaskOne
                            *COM*:0000000000000080 Stack1
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:599    .text:0000000000000194 nrk_register_drivers
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:706    .progmem.data:000000000000001f __c.3176
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//ccFLjkOZ.s:636    .text.startup:0000000000000000 main
                            *COM*:0000000000000001 app_timer0_prescale
                            *COM*:0000000000000002 app_timer0_callback
                            *COM*:0000000000000001 _nrk_time_trigger
                            *COM*:0000000000000001 _nrk_prev_timer_val
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000080 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
__floatunsisf
__fixunssfsi
__udivmodhi4
sqrt
nrk_open
nrk_kprintf
nrk_set_status
nrk_spin_wait_us
nrk_read
nrk_wait_until_next_period
printf
nrk_task_set_stk
nrk_activate_task
dev_manager_ff3_sensors
nrk_register_driver
nrk_setup_ports
nrk_setup_uart
puts
nrk_init
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
