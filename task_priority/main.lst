   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 291               		.section	.rodata.str1.1,"aMS",@progbits,1
 292               	.LC0:
 293 0000 6461 726B 		.string	"dark \r"
 293      200D 00
 294               	.LC1:
 295 0007 6461 796C 		.string	"daylight \r"
 295      6967 6874 
 295      200D 00
 296               	.LC2:
 297 0012 726F 6F6D 		.string	"room-light \r"
 297      2D6C 6967 
 297      6874 200D 
 297      00
 298               	.LC3:
 299 001f 4D79 206E 		.string	"My node's address is %d\r\n"
 299      6F64 6527 
 299      7320 6164 
 299      6472 6573 
 299      7320 6973 
 300               	.LC4:
 301 0039 5461 736B 		.string	"Task1 PID=%d\r\n"
 301      3120 5049 
 301      443D 2564 
 301      0D0A 00
 302               	.LC5:
 303 0048 5065 7263 		.string	"Percent humidity (in %%)= %lu, "
 303      656E 7420 
 303      6875 6D69 
 303      6469 7479 
 303      2028 696E 
 304               	.global	__udivdi3
 305               	.LC6:
 306 0068 2044 6967 		.string	" Digital Temperature (in F)= %d, "
 306      6974 616C 
 306      2054 656D 
 306      7065 7261 
 306      7475 7265 
 307               	.LC7:
 308 008a 2041 6D62 		.string	" Ambient light (in lumens)= %d, "
 308      6965 6E74 
 308      206C 6967 
 308      6874 2028 
 308      696E 206C 
 309               	.LC8:
 310 00ab 204C 6967 		.string	" Light type detected as %s\r\n"
 310      6874 2074 
 310      7970 6520 
 310      6465 7465 
 310      6374 6564 
 311               	.global	__muldi3
 312               	.LC9:
 313 00c8 4261 726F 		.string	"Barometric Pressure (in. Hg)= %d, "
 313      6D65 7472 
 313      6963 2050 
 313      7265 7373 
 313      7572 6520 
 314               	.LC10:
 315 00eb 2041 6363 		.string	" Acceleration - X (ft / sec^2) =%d, "
 315      656C 6572 
 315      6174 696F 
 315      6E20 2D20 
 315      5820 2866 
 316               	.LC11:
 317 0110 2041 6363 		.string	" Acceleration - Y (ft / sec^2) =%d\r\n"
 317      656C 6572 
 317      6174 696F 
 317      6E20 2D20 
 317      5920 2866 
 318               	.LC12:
 319 0135 4D6F 7469 		.string	"Motion based on Infrared = Yes "
 319      6F6E 2062 
 319      6173 6564 
 319      206F 6E20 
 319      496E 6672 
 320               	.LC13:
 321 0155 4D6F 7469 		.string	"Motion based on Infrared = No "
 321      6F6E 2062 
 321      6173 6564 
 321      206F 6E20 
 321      496E 6672 
 322               	.LC14:
 323 0174 204D 6F74 		.string	" Motion based on light change = Yes \r"
 323      696F 6E20 
 323      6261 7365 
 323      6420 6F6E 
 323      206C 6967 
 324               	.LC15:
 325 019a 204D 6F74 		.string	" Motion based on light change = No \r"
 325      696F 6E20 
 325      6261 7365 
 325      6420 6F6E 
 325      206C 6967 
 326               		.text
 328               	.global	print_sensor_readings
 330               	print_sensor_readings:
 331               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *  Contributing Authors (specific to this file):
  23:main.c        **** *  Zane Starr
  24:main.c        **** *******************************************************************************/
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** #include <nrk.h>
  28:main.c        **** #include <include.h>
  29:main.c        **** #include <ulib.h>
  30:main.c        **** #include <stdio.h>
  31:main.c        **** #include <avr/sleep.h>
  32:main.c        **** #include <hal.h>
  33:main.c        **** #include <nrk_error.h>
  34:main.c        **** #include <nrk_timer.h>
  35:main.c        **** #include <nrk_driver_list.h>
  36:main.c        **** #include <nrk_driver.h>
  37:main.c        **** #include <ff_basic_sensor.h>
  38:main.c        **** 
  39:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  40:main.c        **** nrk_task_type TaskOne;
  41:main.c        **** void print_sensor_readings(void);
  42:main.c        **** 
  43:main.c        **** nrk_task_type TaskTwo;
  44:main.c        **** NRK_STK Stack2[NRK_APP_STACKSIZE];
  45:main.c        **** void collect_Audio_Data(void);
  46:main.c        **** 
  47:main.c        **** uint16_t * audio_data;
  48:main.c        **** int8_t audio_data_size;
  49:main.c        **** uint16_t calculate_rms(uint16_t audios [], int8_t window_size);
  50:main.c        **** 
  51:main.c        **** void nrk_create_taskset();
  52:main.c        **** void nrk_register_drivers();
  53:main.c        **** uint8_t kill_stack(uint8_t val);
  54:main.c        **** 
  55:main.c        **** int
  56:main.c        **** main ()
  57:main.c        **** {
  58:main.c        ****   uint8_t t;
  59:main.c        ****   nrk_setup_ports();
  60:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        ****   printf( PSTR("starting...\r\n") );
  64:main.c        **** 
  65:main.c        ****   audio_data_size = 30;
  66:main.c        ****   audio_data = malloc(audio_data_size * (sizeof audio_data[0]));
  67:main.c        **** 
  68:main.c        ****   nrk_init();
  69:main.c        ****   nrk_time_set(0,0);
  70:main.c        **** 
  71:main.c        ****   nrk_register_drivers();
  72:main.c        ****   nrk_create_taskset ();
  73:main.c        ****   nrk_start();
  74:main.c        ****   
  75:main.c        ****   return 0;
  76:main.c        **** }
  77:main.c        **** 
  78:main.c        **** void
  79:main.c        **** nrk_create_taskset()
  80:main.c        **** {
  81:main.c        ****   TaskOne.task = print_sensor_readings;
  82:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
  83:main.c        ****   TaskOne.prio = 1;
  84:main.c        ****   TaskOne.FirstActivation = TRUE;
  85:main.c        ****   TaskOne.Type = BASIC_TASK;
  86:main.c        ****   TaskOne.SchType = PREEMPTIVE;
  87:main.c        ****   TaskOne.period.secs = 2;
  88:main.c        ****   TaskOne.period.nano_secs = 0;
  89:main.c        ****   TaskOne.cpu_reserve.secs = 0;
  90:main.c        ****   TaskOne.cpu_reserve.nano_secs = 0;
  91:main.c        ****   TaskOne.offset.secs = 0;
  92:main.c        ****   TaskOne.offset.nano_secs= 0;
  93:main.c        ****   nrk_activate_task (&TaskOne);
  94:main.c        **** 
  95:main.c        ****   nrk_task_set_entry_function( &TaskTwo, collect_Audio_Data);
  96:main.c        ****   nrk_task_set_stk( &TaskTwo, Stack2, NRK_APP_STACKSIZE);
  97:main.c        ****   TaskTwo.prio = 2;
  98:main.c        ****   TaskTwo.FirstActivation = TRUE;
  99:main.c        ****   TaskTwo.Type = BASIC_TASK;
 100:main.c        ****   TaskTwo.SchType = PREEMPTIVE;
 101:main.c        ****   TaskTwo.period.secs = 2;
 102:main.c        ****   TaskTwo.period.nano_secs = 0;
 103:main.c        ****   TaskTwo.cpu_reserve.secs = 0;
 104:main.c        ****   TaskTwo.cpu_reserve.nano_secs = 0;
 105:main.c        ****   TaskTwo.offset.secs = 0;
 106:main.c        ****   TaskTwo.offset.nano_secs= 0;
 107:main.c        ****   nrk_activate_task (&TaskTwo);
 108:main.c        **** }
 109:main.c        **** 
 110:main.c        **** 
 111:main.c        **** void print_sensor_readings()
 112:main.c        **** {
 333               	.LM0:
 334               	.LFBB1:
 335 0000 CF93      		push r28
 336 0002 DF93      		push r29
 337 0004 CDB7      		in r28,__SP_L__
 338 0006 DEB7      		in r29,__SP_H__
 339 0008 2E97      		sbiw r28,14
 340 000a 0FB6      		in __tmp_reg__,__SREG__
 341 000c F894      		cli
 342 000e DEBF      		out __SP_H__,r29
 343 0010 0FBE      		out __SREG__,__tmp_reg__
 344 0012 CDBF      		out __SP_L__,r28
 345               	/* prologue: function */
 346               	/* frame size = 14 */
 347               	/* stack size = 16 */
 348               	.L__stack_usage = 16
 113:main.c        **** uint16_t cnt;
 114:main.c        **** int8_t i,fd,val;
 115:main.c        **** uint16_t buf;
 116:main.c        **** uint16_t buf_last = 0;
 117:main.c        **** uint16_t motions[] = {0,0};
 350               	.LM1:
 351 0014 1A86      		std Y+10,__zero_reg__
 352 0016 1986      		std Y+9,__zero_reg__
 353 0018 1C86      		std Y+12,__zero_reg__
 354 001a 1B86      		std Y+11,__zero_reg__
 118:main.c        **** uint16_t index = 0;
 119:main.c        **** uint64_t bbuf;
 120:main.c        **** 
 121:main.c        ****   printf( "My node's address is %d\r\n",NODE_ADDR );
 356               	.LM2:
 357 001c 1F92      		push __zero_reg__
 358 001e 1F92      		push __zero_reg__
 359 0020 80E0      		ldi r24,lo8(.LC3)
 360 0022 90E0      		ldi r25,hi8(.LC3)
 361 0024 9F93      		push r25
 362 0026 8F93      		push r24
 363 0028 0E94 0000 		call printf
 122:main.c        **** 
 123:main.c        ****   printf( "Task1 PID=%d\r\n",nrk_get_pid());
 365               	.LM3:
 366 002c 0E94 0000 		call nrk_get_pid
 367 0030 1F92      		push __zero_reg__
 368 0032 8F93      		push r24
 369 0034 80E0      		ldi r24,lo8(.LC4)
 370 0036 90E0      		ldi r25,hi8(.LC4)
 371 0038 9F93      		push r25
 372 003a 8F93      		push r24
 373 003c 0E94 0000 		call printf
 124:main.c        **** 
 125:main.c        ****   
 126:main.c        ****   	// Open ADC device as read 
 127:main.c        ****   	fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 375               	.LM4:
 376 0040 65E0      		ldi r22,lo8(5)
 377 0042 83E0      		ldi r24,lo8(3)
 378 0044 0E94 0000 		call nrk_open
 379 0048 382E      		mov r3,r24
 128:main.c        ****   	if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 381               	.LM5:
 382 004a 0FB6      		in __tmp_reg__,__SREG__
 383 004c F894      		cli
 384 004e DEBF      		out __SP_H__,r29
 385 0050 0FBE      		out __SREG__,__tmp_reg__
 386 0052 CDBF      		out __SP_L__,r28
 387 0054 3FEF      		ldi r19,lo8(-1)
 388 0056 8313      		cpse r24,r19
 389 0058 00C0      		rjmp .L2
 391               	.LM6:
 392 005a 80E0      		ldi r24,lo8(__c.3168)
 393 005c 90E0      		ldi r25,hi8(__c.3168)
 394 005e 0E94 0000 		call nrk_kprintf
 395               	.L2:
 112:main.c        **** {
 397               	.LM7:
 398 0062 812C      		mov r8,__zero_reg__
 399 0064 912C      		mov r9,__zero_reg__
 400               	.LBB2:
 129:main.c        **** 
 130:main.c        **** 	cnt=0;
 131:main.c        **** 	while(1) 
 132:main.c        **** 	{
 133:main.c        **** 
 134:main.c        **** 		// humidity = 37% temperature(A) = 59.7F temperature(D) = 77.1F pressure= 29.85inHg  light=259lm 
 135:main.c        **** 		// Example of setting a sensor 
 136:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,HUMIDITY);
 137:main.c        **** 		val=nrk_read(fd,&bbuf,4); //percent humidity
 138:main.c        **** 		// Relative Humidity (%)  linear          |  1 |    0 |         0 |       100 |
 139:main.c        **** 		printf( "Percent humidity (in %%)= %lu, ",bbuf);
 140:main.c        **** 
 141:main.c        **** 	    // | digital_temp | Temperature (digital sensor, F) | linear          |              0.18 |   
 142:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,TEMP2);
 143:main.c        **** 		val=nrk_read(fd,&bbuf,4); 
 144:main.c        **** 		uint16_t temp_converted = ((9*bbuf)/5)+ 32;
 145:main.c        **** 		printf( " Digital Temperature (in F)= %d, ", temp_converted/10);
 146:main.c        **** 
 147:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,LIGHT);
 148:main.c        **** 		val=nrk_read(fd,&buf,2);
 149:main.c        **** 		// light        | Incident Illumination (lumens)  | linear          |                -1 | 1024 | 
 150:main.c        **** 	    char *light_type;
 151:main.c        **** 
 152:main.c        **** 		if(buf > 1000){
 153:main.c        **** 			light_type= "dark \r";
 154:main.c        **** 		}
 155:main.c        **** 		else
 156:main.c        **** 		{
 157:main.c        **** 			if(buf < 580){
 158:main.c        **** 				light_type= "daylight \r";
 159:main.c        **** 			}
 160:main.c        **** 			else
 161:main.c        **** 			{
 162:main.c        **** 				light_type= "room-light \r";
 163:main.c        **** 			}
 164:main.c        **** 		}
 165:main.c        **** 
 166:main.c        **** 	    
 167:main.c        **** 		printf( " Ambient light (in lumens)= %d, ",-1*buf + 1024);
 168:main.c        **** 	    printf( " Light type detected as %s\r\n", light_type);
 169:main.c        **** 		
 170:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,PRESS);
 171:main.c        **** 		val=nrk_read(fd,&bbuf,4);
 172:main.c        **** 		// pressure     | Barometric Pressure (in. Hg)    | linear          | 0.000295780903035 |    0 | 
 173:main.c        **** 		printf( "Barometric Pressure (in. Hg)= %d, ",295*(bbuf)/1000000);
 402               	.LM8:
 403 0066 10E0      		ldi r17,lo8(.LC9)
 404 0068 612E      		mov r6,r17
 405 006a 10E0      		ldi r17,hi8(.LC9)
 406 006c 712E      		mov r7,r17
 174:main.c        **** 		
 175:main.c        **** 		// | acc_x        | Acceleration - X (ft / sec^2)   | linear          |                 1 |    0 
 176:main.c        **** 		// | acc_y        | Acceleration - Y (ft / sec^2)   | linear          |                 1 |    0 
 177:main.c        **** 		// | acc_z        | Acceleration - Z (ft / sec^2)   | linear          |                 1 |    0 
 178:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, ACC_X);
 179:main.c        **** 		val=nrk_read(fd,&buf,2);
 180:main.c        **** 		printf( " Acceleration - X (ft / sec^2) =%d, ",buf);
 408               	.LM9:
 409 006e 00E0      		ldi r16,lo8(.LC10)
 410 0070 402E      		mov r4,r16
 411 0072 00E0      		ldi r16,hi8(.LC10)
 412 0074 502E      		mov r5,r16
 413               	.L9:
 136:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,HUMIDITY);
 415               	.LM10:
 416 0076 4BE0      		ldi r20,lo8(11)
 417 0078 61E0      		ldi r22,lo8(1)
 418 007a 832D      		mov r24,r3
 419 007c 0E94 0000 		call nrk_set_status
 137:main.c        **** 		val=nrk_read(fd,&bbuf,4); //percent humidity
 421               	.LM11:
 422 0080 44E0      		ldi r20,lo8(4)
 423 0082 BE01      		movw r22,r28
 424 0084 6F5F      		subi r22,-1
 425 0086 7F4F      		sbci r23,-1
 426 0088 832D      		mov r24,r3
 427 008a 0E94 0000 		call nrk_read
 139:main.c        **** 		printf( "Percent humidity (in %%)= %lu, ",bbuf);
 429               	.LM12:
 430 008e 8885      		ldd r24,Y+8
 431 0090 8F93      		push r24
 432 0092 8F81      		ldd r24,Y+7
 433 0094 8F93      		push r24
 434 0096 8E81      		ldd r24,Y+6
 435 0098 8F93      		push r24
 436 009a 8D81      		ldd r24,Y+5
 437 009c 8F93      		push r24
 438 009e 8C81      		ldd r24,Y+4
 439 00a0 8F93      		push r24
 440 00a2 8B81      		ldd r24,Y+3
 441 00a4 8F93      		push r24
 442 00a6 8A81      		ldd r24,Y+2
 443 00a8 8F93      		push r24
 444 00aa 8981      		ldd r24,Y+1
 445 00ac 8F93      		push r24
 446 00ae 80E0      		ldi r24,lo8(.LC5)
 447 00b0 90E0      		ldi r25,hi8(.LC5)
 448 00b2 9F93      		push r25
 449 00b4 8F93      		push r24
 450 00b6 0E94 0000 		call printf
 142:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,TEMP2);
 452               	.LM13:
 453 00ba 4AE0      		ldi r20,lo8(10)
 454 00bc 61E0      		ldi r22,lo8(1)
 455 00be 832D      		mov r24,r3
 456 00c0 0E94 0000 		call nrk_set_status
 143:main.c        **** 		val=nrk_read(fd,&bbuf,4); 
 458               	.LM14:
 459 00c4 44E0      		ldi r20,lo8(4)
 460 00c6 BE01      		movw r22,r28
 461 00c8 6F5F      		subi r22,-1
 462 00ca 7F4F      		sbci r23,-1
 463 00cc 832D      		mov r24,r3
 464 00ce 0E94 0000 		call nrk_read
 144:main.c        **** 		uint16_t temp_converted = ((9*bbuf)/5)+ 32;
 466               	.LM15:
 467 00d2 A980      		ldd r10,Y+1
 468 00d4 BA80      		ldd r11,Y+2
 469 00d6 CB80      		ldd r12,Y+3
 470 00d8 DC80      		ldd r13,Y+4
 471 00da ED80      		ldd r14,Y+5
 472 00dc FE80      		ldd r15,Y+6
 473 00de EF81      		ldd r30,Y+7
 474 00e0 1885      		ldd r17,Y+8
 475 00e2 9501      		movw r18,r10
 476 00e4 A601      		movw r20,r12
 477 00e6 B701      		movw r22,r14
 478 00e8 8E2F      		mov r24,r30
 479 00ea 912F      		mov r25,r17
 480 00ec 03E0      		ldi r16,lo8(3)
 481 00ee 0E94 0000 		call __ashldi3
 482 00f2 0E2F      		mov r16,r30
 483 00f4 0E94 0000 		call __adddi3
 484 00f8 B5E0      		ldi r27,lo8(5)
 485 00fa AB2E      		mov r10,r27
 486 00fc B12C      		mov r11,__zero_reg__
 487 00fe C12C      		mov r12,__zero_reg__
 488 0100 D12C      		mov r13,__zero_reg__
 489 0102 E12C      		mov r14,__zero_reg__
 490 0104 F12C      		mov r15,__zero_reg__
 491 0106 00E0      		ldi r16,0
 492 0108 10E0      		ldi r17,0
 493 010a 0E94 0000 		call __udivdi3
 494 010e C901      		movw r24,r18
 495 0110 8096      		adiw r24,32
 145:main.c        **** 		printf( " Digital Temperature (in F)= %d, ", temp_converted/10);
 497               	.LM16:
 498 0112 6AE0      		ldi r22,lo8(10)
 499 0114 70E0      		ldi r23,0
 500 0116 0E94 0000 		call __udivmodhi4
 501 011a 7F93      		push r23
 502 011c 6F93      		push r22
 503 011e 80E0      		ldi r24,lo8(.LC6)
 504 0120 90E0      		ldi r25,hi8(.LC6)
 505 0122 9F93      		push r25
 506 0124 8F93      		push r24
 507 0126 0E94 0000 		call printf
 147:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,LIGHT);
 509               	.LM17:
 510 012a 41E0      		ldi r20,lo8(1)
 511 012c 61E0      		ldi r22,lo8(1)
 512 012e 832D      		mov r24,r3
 513 0130 0E94 0000 		call nrk_set_status
 148:main.c        **** 		val=nrk_read(fd,&buf,2);
 515               	.LM18:
 516 0134 42E0      		ldi r20,lo8(2)
 517 0136 BE01      		movw r22,r28
 518 0138 635F      		subi r22,-13
 519 013a 7F4F      		sbci r23,-1
 520 013c 832D      		mov r24,r3
 521 013e 0E94 0000 		call nrk_read
 152:main.c        **** 		if(buf > 1000){
 523               	.LM19:
 524 0142 8D85      		ldd r24,Y+13
 525 0144 9E85      		ldd r25,Y+14
 526 0146 0FB6      		in __tmp_reg__,__SREG__
 527 0148 F894      		cli
 528 014a DEBF      		out __SP_H__,r29
 529 014c 0FBE      		out __SREG__,__tmp_reg__
 530 014e CDBF      		out __SP_L__,r28
 531 0150 893E      		cpi r24,-23
 532 0152 33E0      		ldi r19,3
 533 0154 9307      		cpc r25,r19
 534 0156 00F4      		brsh .L10
 157:main.c        **** 			if(buf < 580){
 536               	.LM20:
 537 0158 8434      		cpi r24,68
 538 015a 22E0      		ldi r18,2
 539 015c 9207      		cpc r25,r18
 540 015e 00F4      		brsh .L11
 158:main.c        **** 				light_type= "daylight \r";
 542               	.LM21:
 543 0160 00E0      		ldi r16,lo8(.LC1)
 544 0162 10E0      		ldi r17,hi8(.LC1)
 545 0164 00C0      		rjmp .L3
 546               	.L10:
 153:main.c        **** 			light_type= "dark \r";
 548               	.LM22:
 549 0166 00E0      		ldi r16,lo8(.LC0)
 550 0168 10E0      		ldi r17,hi8(.LC0)
 551 016a 00C0      		rjmp .L3
 552               	.L11:
 162:main.c        **** 				light_type= "room-light \r";
 554               	.LM23:
 555 016c 00E0      		ldi r16,lo8(.LC2)
 556 016e 10E0      		ldi r17,hi8(.LC2)
 557               	.L3:
 167:main.c        **** 		printf( " Ambient light (in lumens)= %d, ",-1*buf + 1024);
 559               	.LM24:
 560 0170 20E0      		ldi r18,0
 561 0172 34E0      		ldi r19,lo8(4)
 562 0174 281B      		sub r18,r24
 563 0176 390B      		sbc r19,r25
 564 0178 C901      		movw r24,r18
 565 017a 9F93      		push r25
 566 017c 2F93      		push r18
 567 017e 80E0      		ldi r24,lo8(.LC7)
 568 0180 90E0      		ldi r25,hi8(.LC7)
 569 0182 9F93      		push r25
 570 0184 8F93      		push r24
 571 0186 0E94 0000 		call printf
 168:main.c        **** 	    printf( " Light type detected as %s\r\n", light_type);
 573               	.LM25:
 574 018a 1F93      		push r17
 575 018c 0F93      		push r16
 576 018e 80E0      		ldi r24,lo8(.LC8)
 577 0190 90E0      		ldi r25,hi8(.LC8)
 578 0192 9F93      		push r25
 579 0194 8F93      		push r24
 580 0196 0E94 0000 		call printf
 170:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,PRESS);
 582               	.LM26:
 583 019a 49E0      		ldi r20,lo8(9)
 584 019c 61E0      		ldi r22,lo8(1)
 585 019e 832D      		mov r24,r3
 586 01a0 0E94 0000 		call nrk_set_status
 171:main.c        **** 		val=nrk_read(fd,&bbuf,4);
 588               	.LM27:
 589 01a4 44E0      		ldi r20,lo8(4)
 590 01a6 BE01      		movw r22,r28
 591 01a8 6F5F      		subi r22,-1
 592 01aa 7F4F      		sbci r23,-1
 593 01ac 832D      		mov r24,r3
 594 01ae 0E94 0000 		call nrk_read
 173:main.c        **** 		printf( "Barometric Pressure (in. Hg)= %d, ",295*(bbuf)/1000000);
 596               	.LM28:
 597 01b2 27E2      		ldi r18,lo8(39)
 598 01b4 A22E      		mov r10,r18
 599 01b6 BB24      		clr r11
 600 01b8 B394      		inc r11
 601 01ba C12C      		mov r12,__zero_reg__
 602 01bc D12C      		mov r13,__zero_reg__
 603 01be E12C      		mov r14,__zero_reg__
 604 01c0 F12C      		mov r15,__zero_reg__
 605 01c2 00E0      		ldi r16,0
 606 01c4 10E0      		ldi r17,0
 607 01c6 2981      		ldd r18,Y+1
 608 01c8 3A81      		ldd r19,Y+2
 609 01ca 4B81      		ldd r20,Y+3
 610 01cc 5C81      		ldd r21,Y+4
 611 01ce 6D81      		ldd r22,Y+5
 612 01d0 7E81      		ldd r23,Y+6
 613 01d2 8F81      		ldd r24,Y+7
 614 01d4 9885      		ldd r25,Y+8
 615 01d6 0E94 0000 		call __muldi3
 616 01da E0E4      		ldi r30,lo8(64)
 617 01dc AE2E      		mov r10,r30
 618 01de F2E4      		ldi r31,lo8(66)
 619 01e0 BF2E      		mov r11,r31
 620 01e2 AFE0      		ldi r26,lo8(15)
 621 01e4 CA2E      		mov r12,r26
 622 01e6 0E94 0000 		call __udivdi3
 623 01ea 9F93      		push r25
 624 01ec 8F93      		push r24
 625 01ee 7F93      		push r23
 626 01f0 6F93      		push r22
 627 01f2 5F93      		push r21
 628 01f4 4F93      		push r20
 629 01f6 3F93      		push r19
 630 01f8 2F93      		push r18
 631 01fa 7F92      		push r7
 632 01fc 6F92      		push r6
 633 01fe 0E94 0000 		call printf
 178:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, ACC_X);
 635               	.LM29:
 636 0202 44E0      		ldi r20,lo8(4)
 637 0204 61E0      		ldi r22,lo8(1)
 638 0206 832D      		mov r24,r3
 639 0208 0E94 0000 		call nrk_set_status
 179:main.c        **** 		val=nrk_read(fd,&buf,2);
 641               	.LM30:
 642 020c 42E0      		ldi r20,lo8(2)
 643 020e BE01      		movw r22,r28
 644 0210 635F      		subi r22,-13
 645 0212 7F4F      		sbci r23,-1
 646 0214 832D      		mov r24,r3
 647 0216 0E94 0000 		call nrk_read
 649               	.LM31:
 650 021a 8E85      		ldd r24,Y+14
 651 021c 8F93      		push r24
 652 021e 8D85      		ldd r24,Y+13
 653 0220 8F93      		push r24
 654 0222 5F92      		push r5
 655 0224 4F92      		push r4
 656 0226 0E94 0000 		call printf
 181:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, ACC_Y);
 658               	.LM32:
 659 022a 45E0      		ldi r20,lo8(5)
 660 022c 61E0      		ldi r22,lo8(1)
 661 022e 832D      		mov r24,r3
 662 0230 0E94 0000 		call nrk_set_status
 182:main.c        **** 		val=nrk_read(fd,&buf,2);
 664               	.LM33:
 665 0234 42E0      		ldi r20,lo8(2)
 666 0236 BE01      		movw r22,r28
 667 0238 635F      		subi r22,-13
 668 023a 7F4F      		sbci r23,-1
 669 023c 832D      		mov r24,r3
 670 023e 0E94 0000 		call nrk_read
 183:main.c        **** 		printf( " Acceleration - Y (ft / sec^2) =%d\r\n",buf);
 672               	.LM34:
 673 0242 8E85      		ldd r24,Y+14
 674 0244 8F93      		push r24
 675 0246 8D85      		ldd r24,Y+13
 676 0248 8F93      		push r24
 677 024a 80E0      		ldi r24,lo8(.LC11)
 678 024c 90E0      		ldi r25,hi8(.LC11)
 679 024e 9F93      		push r25
 680 0250 8F93      		push r24
 681 0252 0E94 0000 		call printf
 184:main.c        **** 
 185:main.c        **** 
 186:main.c        **** 		// motion       | Motion Detected (binary)        | threshhold      |               950 |    0 | 
 187:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT, MOTION);		
 683               	.LM35:
 684 0256 46E0      		ldi r20,lo8(6)
 685 0258 61E0      		ldi r22,lo8(1)
 686 025a 832D      		mov r24,r3
 687 025c 0E94 0000 		call nrk_set_status
 188:main.c        **** 		val=nrk_read(fd,&buf,2);
 689               	.LM36:
 690 0260 42E0      		ldi r20,lo8(2)
 691 0262 BE01      		movw r22,r28
 692 0264 635F      		subi r22,-13
 693 0266 7F4F      		sbci r23,-1
 694 0268 832D      		mov r24,r3
 695 026a 0E94 0000 		call nrk_read
 189:main.c        **** 		// printf( " Motion value =%d\r\n",buf);
 190:main.c        **** 		if(buf> 990){
 697               	.LM37:
 698 026e 0FB6      		in __tmp_reg__,__SREG__
 699 0270 F894      		cli
 700 0272 DEBF      		out __SP_H__,r29
 701 0274 0FBE      		out __SREG__,__tmp_reg__
 702 0276 CDBF      		out __SP_L__,r28
 703 0278 8D85      		ldd r24,Y+13
 704 027a 9E85      		ldd r25,Y+14
 705 027c 8F3D      		cpi r24,-33
 706 027e 9340      		sbci r25,3
 707 0280 00F0      		brlo .L4
 191:main.c        **** 			printf( "Motion based on Infrared = Yes ");
 709               	.LM38:
 710 0282 80E0      		ldi r24,lo8(.LC12)
 711 0284 90E0      		ldi r25,hi8(.LC12)
 712 0286 00C0      		rjmp .L12
 713               	.L4:
 192:main.c        **** 		}
 193:main.c        **** 		else
 194:main.c        **** 		{
 195:main.c        **** 			printf( "Motion based on Infrared = No ");
 715               	.LM39:
 716 0288 80E0      		ldi r24,lo8(.LC13)
 717 028a 90E0      		ldi r25,hi8(.LC13)
 718               	.L12:
 719 028c 9F93      		push r25
 720 028e 8F93      		push r24
 721 0290 0E94 0000 		call printf
 722 0294 0F90      		pop __tmp_reg__
 723 0296 0F90      		pop __tmp_reg__
 196:main.c        **** 		}
 197:main.c        **** 
 198:main.c        **** 		uint16_t sum = 0;
 199:main.c        **** 	    int size = sizeof(motions)/sizeof(motions[0]);
 200:main.c        **** 		for ( i = 0; i < size; i++ )
 201:main.c        **** 	     {
 202:main.c        **** 	      sum = sum + motions[i];
 725               	.LM40:
 726 0298 0B85      		ldd r16,Y+11
 727 029a 1C85      		ldd r17,Y+12
 728 029c 8985      		ldd r24,Y+9
 729 029e 9A85      		ldd r25,Y+10
 730 02a0 080F      		add r16,r24
 731 02a2 191F      		adc r17,r25
 203:main.c        **** 	     }
 204:main.c        **** 
 205:main.c        **** 		uint16_t avg = sum/size;
 733               	.LM41:
 734 02a4 1695      		lsr r17
 735 02a6 0795      		ror r16
 206:main.c        **** 
 207:main.c        **** 	    nrk_led_clr(RED_LED);
 737               	.LM42:
 738 02a8 80E0      		ldi r24,0
 739 02aa 90E0      		ldi r25,0
 740 02ac 0E94 0000 		call nrk_led_clr
 208:main.c        **** 	    nrk_led_clr(GREEN_LED);
 742               	.LM43:
 743 02b0 81E0      		ldi r24,lo8(1)
 744 02b2 90E0      		ldi r25,0
 745 02b4 0E94 0000 		call nrk_led_clr
 209:main.c        **** 
 210:main.c        **** 	    printf( ":");
 747               	.LM44:
 748 02b8 8AE3      		ldi r24,lo8(58)
 749 02ba 90E0      		ldi r25,0
 750 02bc 0E94 0000 		call putchar
 751               	.LBB3:
 211:main.c        **** 		if( abs(buf - avg) >10)
 753               	.LM45:
 754 02c0 8D85      		ldd r24,Y+13
 755 02c2 9E85      		ldd r25,Y+14
 756 02c4 801B      		sub r24,r16
 757 02c6 910B      		sbc r25,r17
 758 02c8 97FF      		sbrs r25,7
 759 02ca 00C0      		rjmp .L7
 760 02cc 9195      		neg r25
 761 02ce 8195      		neg r24
 762 02d0 9109      		sbc r25,__zero_reg__
 763               	.L7:
 764 02d2 0B97      		sbiw r24,11
 765 02d4 04F0      		brlt .L6
 212:main.c        **** 		//if( abs(buf - buf_last) >2)
 213:main.c        **** 			{ printf(" Motion based on light change = Yes \r\n" );
 767               	.LM46:
 768 02d6 80E0      		ldi r24,lo8(.LC14)
 769 02d8 90E0      		ldi r25,hi8(.LC14)
 770 02da 0E94 0000 		call puts
 214:main.c        **** 		      nrk_led_toggle(RED_LED);
 772               	.LM47:
 773 02de 80E0      		ldi r24,0
 774 02e0 90E0      		ldi r25,0
 775 02e2 00C0      		rjmp .L13
 776               	.L6:
 215:main.c        **** 		  	}
 216:main.c        **** 		else 
 217:main.c        **** 		{
 218:main.c        **** 			printf(" Motion based on light change = No \r\n" );
 778               	.LM48:
 779 02e4 80E0      		ldi r24,lo8(.LC15)
 780 02e6 90E0      		ldi r25,hi8(.LC15)
 781 02e8 0E94 0000 		call puts
 219:main.c        **** 			nrk_led_toggle(GREEN_LED);
 783               	.LM49:
 784 02ec 81E0      		ldi r24,lo8(1)
 785 02ee 90E0      		ldi r25,0
 786               	.L13:
 787 02f0 0E94 0000 		call nrk_led_toggle
 788               	.LBE3:
 220:main.c        **** 		}
 221:main.c        **** 
 222:main.c        **** 		motions[index] = buf;
 790               	.LM50:
 791 02f4 F401      		movw r30,r8
 792 02f6 EE0F      		lsl r30
 793 02f8 FF1F      		rol r31
 794 02fa 81E0      		ldi r24,lo8(1)
 795 02fc 90E0      		ldi r25,0
 796 02fe 8C0F      		add r24,r28
 797 0300 9D1F      		adc r25,r29
 798 0302 E80F      		add r30,r24
 799 0304 F91F      		adc r31,r25
 800 0306 8D85      		ldd r24,Y+13
 801 0308 9E85      		ldd r25,Y+14
 802 030a 9187      		std Z+9,r25
 803 030c 8087      		std Z+8,r24
 223:main.c        **** 
 224:main.c        **** 		buf_last = buf; 
 225:main.c        **** 
 226:main.c        **** 
 227:main.c        **** 		nrk_wait_until_next_period();
 805               	.LM51:
 806 030e 0E94 0000 		call nrk_wait_until_next_period
 228:main.c        **** 		cnt++;
 229:main.c        **** 
 230:main.c        **** 		index++;
 231:main.c        **** 		if(index == size) index =0;
 808               	.LM52:
 809 0312 91E0      		ldi r25,1
 810 0314 8926      		eor r8,r25
 811 0316 00C0      		rjmp .L9
 812               	.LBE2:
 825               	.Lscope1:
 827               		.stabd	78,0,0
 829               	.global	nrk_create_taskset
 831               	nrk_create_taskset:
 832               		.stabd	46,0,0
  80:main.c        **** {
 834               	.LM53:
 835               	.LFBB2:
 836 0318 CF92      		push r12
 837 031a DF92      		push r13
 838 031c EF92      		push r14
 839 031e FF92      		push r15
 840 0320 CF93      		push r28
 841               	/* prologue: function */
 842               	/* frame size = 0 */
 843               	/* stack size = 5 */
 844               	.L__stack_usage = 5
  81:main.c        ****   TaskOne.task = print_sensor_readings;
 846               	.LM54:
 847 0322 80E0      		ldi r24,lo8(gs(print_sensor_readings))
 848 0324 90E0      		ldi r25,hi8(gs(print_sensor_readings))
 849 0326 9093 0000 		sts TaskOne+5+1,r25
 850 032a 8093 0000 		sts TaskOne+5,r24
  82:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
 852               	.LM55:
 853 032e 40E8      		ldi r20,lo8(-128)
 854 0330 50E0      		ldi r21,0
 855 0332 60E0      		ldi r22,lo8(Stack1)
 856 0334 70E0      		ldi r23,hi8(Stack1)
 857 0336 80E0      		ldi r24,lo8(TaskOne)
 858 0338 90E0      		ldi r25,hi8(TaskOne)
 859 033a 0E94 0000 		call nrk_task_set_stk
  83:main.c        ****   TaskOne.prio = 1;
 861               	.LM56:
 862 033e C1E0      		ldi r28,lo8(1)
 863 0340 C093 0000 		sts TaskOne+8,r28
  84:main.c        ****   TaskOne.FirstActivation = TRUE;
 865               	.LM57:
 866 0344 C093 0000 		sts TaskOne+7,r28
  85:main.c        ****   TaskOne.Type = BASIC_TASK;
 868               	.LM58:
 869 0348 C093 0000 		sts TaskOne+9,r28
  86:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 871               	.LM59:
 872 034c C093 0000 		sts TaskOne+10,r28
  87:main.c        ****   TaskOne.period.secs = 2;
 874               	.LM60:
 875 0350 82E0      		ldi r24,lo8(2)
 876 0352 C82E      		mov r12,r24
 877 0354 D12C      		mov r13,__zero_reg__
 878 0356 E12C      		mov r14,__zero_reg__
 879 0358 F12C      		mov r15,__zero_reg__
 880 035a C092 0000 		sts TaskOne+11,r12
 881 035e D092 0000 		sts TaskOne+11+1,r13
 882 0362 E092 0000 		sts TaskOne+11+2,r14
 883 0366 F092 0000 		sts TaskOne+11+3,r15
  88:main.c        ****   TaskOne.period.nano_secs = 0;
 885               	.LM61:
 886 036a 1092 0000 		sts TaskOne+15,__zero_reg__
 887 036e 1092 0000 		sts TaskOne+15+1,__zero_reg__
 888 0372 1092 0000 		sts TaskOne+15+2,__zero_reg__
 889 0376 1092 0000 		sts TaskOne+15+3,__zero_reg__
  89:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 891               	.LM62:
 892 037a 1092 0000 		sts TaskOne+19,__zero_reg__
 893 037e 1092 0000 		sts TaskOne+19+1,__zero_reg__
 894 0382 1092 0000 		sts TaskOne+19+2,__zero_reg__
 895 0386 1092 0000 		sts TaskOne+19+3,__zero_reg__
  90:main.c        ****   TaskOne.cpu_reserve.nano_secs = 0;
 897               	.LM63:
 898 038a 1092 0000 		sts TaskOne+23,__zero_reg__
 899 038e 1092 0000 		sts TaskOne+23+1,__zero_reg__
 900 0392 1092 0000 		sts TaskOne+23+2,__zero_reg__
 901 0396 1092 0000 		sts TaskOne+23+3,__zero_reg__
  91:main.c        ****   TaskOne.offset.secs = 0;
 903               	.LM64:
 904 039a 1092 0000 		sts TaskOne+27,__zero_reg__
 905 039e 1092 0000 		sts TaskOne+27+1,__zero_reg__
 906 03a2 1092 0000 		sts TaskOne+27+2,__zero_reg__
 907 03a6 1092 0000 		sts TaskOne+27+3,__zero_reg__
  92:main.c        ****   TaskOne.offset.nano_secs= 0;
 909               	.LM65:
 910 03aa 1092 0000 		sts TaskOne+31,__zero_reg__
 911 03ae 1092 0000 		sts TaskOne+31+1,__zero_reg__
 912 03b2 1092 0000 		sts TaskOne+31+2,__zero_reg__
 913 03b6 1092 0000 		sts TaskOne+31+3,__zero_reg__
  93:main.c        ****   nrk_activate_task (&TaskOne);
 915               	.LM66:
 916 03ba 80E0      		ldi r24,lo8(TaskOne)
 917 03bc 90E0      		ldi r25,hi8(TaskOne)
 918 03be 0E94 0000 		call nrk_activate_task
  95:main.c        ****   nrk_task_set_entry_function( &TaskTwo, collect_Audio_Data);
 920               	.LM67:
 921 03c2 60E0      		ldi r22,lo8(gs(collect_Audio_Data))
 922 03c4 70E0      		ldi r23,hi8(gs(collect_Audio_Data))
 923 03c6 80E0      		ldi r24,lo8(TaskTwo)
 924 03c8 90E0      		ldi r25,hi8(TaskTwo)
 925 03ca 0E94 0000 		call nrk_task_set_entry_function
  96:main.c        ****   nrk_task_set_stk( &TaskTwo, Stack2, NRK_APP_STACKSIZE);
 927               	.LM68:
 928 03ce 40E8      		ldi r20,lo8(-128)
 929 03d0 50E0      		ldi r21,0
 930 03d2 60E0      		ldi r22,lo8(Stack2)
 931 03d4 70E0      		ldi r23,hi8(Stack2)
 932 03d6 80E0      		ldi r24,lo8(TaskTwo)
 933 03d8 90E0      		ldi r25,hi8(TaskTwo)
 934 03da 0E94 0000 		call nrk_task_set_stk
  97:main.c        ****   TaskTwo.prio = 2;
 936               	.LM69:
 937 03de 82E0      		ldi r24,lo8(2)
 938 03e0 8093 0000 		sts TaskTwo+8,r24
  98:main.c        ****   TaskTwo.FirstActivation = TRUE;
 940               	.LM70:
 941 03e4 C093 0000 		sts TaskTwo+7,r28
  99:main.c        ****   TaskTwo.Type = BASIC_TASK;
 943               	.LM71:
 944 03e8 C093 0000 		sts TaskTwo+9,r28
 100:main.c        ****   TaskTwo.SchType = PREEMPTIVE;
 946               	.LM72:
 947 03ec C093 0000 		sts TaskTwo+10,r28
 101:main.c        ****   TaskTwo.period.secs = 2;
 949               	.LM73:
 950 03f0 C092 0000 		sts TaskTwo+11,r12
 951 03f4 D092 0000 		sts TaskTwo+11+1,r13
 952 03f8 E092 0000 		sts TaskTwo+11+2,r14
 953 03fc F092 0000 		sts TaskTwo+11+3,r15
 102:main.c        ****   TaskTwo.period.nano_secs = 0;
 955               	.LM74:
 956 0400 1092 0000 		sts TaskTwo+15,__zero_reg__
 957 0404 1092 0000 		sts TaskTwo+15+1,__zero_reg__
 958 0408 1092 0000 		sts TaskTwo+15+2,__zero_reg__
 959 040c 1092 0000 		sts TaskTwo+15+3,__zero_reg__
 103:main.c        ****   TaskTwo.cpu_reserve.secs = 0;
 961               	.LM75:
 962 0410 1092 0000 		sts TaskTwo+19,__zero_reg__
 963 0414 1092 0000 		sts TaskTwo+19+1,__zero_reg__
 964 0418 1092 0000 		sts TaskTwo+19+2,__zero_reg__
 965 041c 1092 0000 		sts TaskTwo+19+3,__zero_reg__
 104:main.c        ****   TaskTwo.cpu_reserve.nano_secs = 0;
 967               	.LM76:
 968 0420 1092 0000 		sts TaskTwo+23,__zero_reg__
 969 0424 1092 0000 		sts TaskTwo+23+1,__zero_reg__
 970 0428 1092 0000 		sts TaskTwo+23+2,__zero_reg__
 971 042c 1092 0000 		sts TaskTwo+23+3,__zero_reg__
 105:main.c        ****   TaskTwo.offset.secs = 0;
 973               	.LM77:
 974 0430 1092 0000 		sts TaskTwo+27,__zero_reg__
 975 0434 1092 0000 		sts TaskTwo+27+1,__zero_reg__
 976 0438 1092 0000 		sts TaskTwo+27+2,__zero_reg__
 977 043c 1092 0000 		sts TaskTwo+27+3,__zero_reg__
 106:main.c        ****   TaskTwo.offset.nano_secs= 0;
 979               	.LM78:
 980 0440 1092 0000 		sts TaskTwo+31,__zero_reg__
 981 0444 1092 0000 		sts TaskTwo+31+1,__zero_reg__
 982 0448 1092 0000 		sts TaskTwo+31+2,__zero_reg__
 983 044c 1092 0000 		sts TaskTwo+31+3,__zero_reg__
 107:main.c        ****   nrk_activate_task (&TaskTwo);
 985               	.LM79:
 986 0450 80E0      		ldi r24,lo8(TaskTwo)
 987 0452 90E0      		ldi r25,hi8(TaskTwo)
 988               	/* epilogue start */
 108:main.c        **** }
 990               	.LM80:
 991 0454 CF91      		pop r28
 992 0456 FF90      		pop r15
 993 0458 EF90      		pop r14
 994 045a DF90      		pop r13
 995 045c CF90      		pop r12
 107:main.c        ****   nrk_activate_task (&TaskTwo);
 997               	.LM81:
 998 045e 0C94 0000 		jmp nrk_activate_task
 1000               	.Lscope2:
 1002               		.stabd	78,0,0
 1003               	.global	__floatunsisf
 1004               	.global	__fixunssfsi
 1005               		.section	.rodata.str1.1
 1006               	.LC16:
 1007 01bf 4175 6469 		.string	"Audio RMS value =%ld\r\n"
 1007      6F20 524D 
 1007      5320 7661 
 1007      6C75 6520 
 1007      3D25 6C64 
 1008               		.text
 1012               	.global	calculate_rms
 1014               	calculate_rms:
 1015               		.stabd	46,0,0
 232:main.c        **** 	}
 233:main.c        **** }
 234:main.c        **** 
 235:main.c        **** void 
 236:main.c        **** collect_Audio_Data(){
 237:main.c        **** printf( "Task PID=%u\r\n",nrk_get_pid());
 238:main.c        **** 
 239:main.c        **** int8_t fd, val, index;
 240:main.c        **** uint16_t buf;
 241:main.c        **** 
 242:main.c        **** 
 243:main.c        **** // Open ADC device as read 
 244:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 245:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 246:main.c        **** 
 247:main.c        **** 	while(1)
 248:main.c        **** 	{
 249:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO);
 250:main.c        ****     	//8 KHZ sensor
 251:main.c        **** 		nrk_spin_wait_us(125);
 252:main.c        **** 		val=nrk_read(fd,&buf,2);
 253:main.c        **** 
 254:main.c        ****     	// printf( " audio=%d\r\n", buf);
 255:main.c        **** 
 256:main.c        **** 		nrk_led_clr(BLUE_LED);
 257:main.c        **** 		nrk_led_clr(RED_LED);
 258:main.c        **** 		nrk_led_toggle(RED_LED);
 259:main.c        **** 
 260:main.c        **** 		audio_data[index] = buf;
 261:main.c        **** 		index++;
 262:main.c        **** 
 263:main.c        **** 		if(index == audio_data_size)
 264:main.c        **** 		{
 265:main.c        **** 			index =0;
 266:main.c        **** 			calculate_rms(audio_data, audio_data_size);
 267:main.c        **** 			// nrk_wait_until_next_period();
 268:main.c        **** 		}
 269:main.c        **** 	}
 270:main.c        **** }
 271:main.c        **** 
 272:main.c        **** uint16_t
 273:main.c        **** calculate_rms(uint16_t audios [], int8_t window_size)
 274:main.c        **** {
 1017               	.LM82:
 1018               	.LFBB3:
 1019 0462 CF92      		push r12
 1020 0464 DF92      		push r13
 1021 0466 EF92      		push r14
 1022 0468 FF92      		push r15
 1023 046a CF93      		push r28
 1024 046c DF93      		push r29
 1025               	/* prologue: function */
 1026               	/* frame size = 0 */
 1027               	/* stack size = 6 */
 1028               	.L__stack_usage = 6
 1029 046e FC01      		movw r30,r24
 1030 0470 D62F      		mov r29,r22
 275:main.c        ****   uint8_t index = 0;
 276:main.c        ****   uint32_t rawrms  =0;
 1032               	.LM83:
 1033 0472 C12C      		mov r12,__zero_reg__
 1034 0474 D12C      		mov r13,__zero_reg__
 1035 0476 7601      		movw r14,r12
 275:main.c        ****   uint8_t index = 0;
 1037               	.LM84:
 1038 0478 C0E0      		ldi r28,0
 277:main.c        ****   uint32_t rms  = 0;
 278:main.c        **** 
 279:main.c        ****   while(index  < window_size)
 1040               	.LM85:
 1041 047a 462F      		mov r20,r22
 1042 047c 5527      		clr r21
 1043 047e 47FD      		sbrc r20,7
 1044 0480 5095      		com r21
 1045 0482 00C0      		rjmp .L16
 1046               	.L17:
 280:main.c        ****   {
 281:main.c        ****     rawrms += (uint32_t)audios[index] * (uint32_t)audios[index];
 1048               	.LM86:
 1049 0484 AA0F      		lsl r26
 1050 0486 BB1F      		rol r27
 1051 0488 AE0F      		add r26,r30
 1052 048a BF1F      		adc r27,r31
 1053 048c 0D90      		ld __tmp_reg__,X+
 1054 048e BC91      		ld r27,X
 1055 0490 A02D      		mov r26,__tmp_reg__
 1056 0492 9D01      		movw r18,r26
 1057 0494 0E94 0000 		call __umulhisi3
 1058 0498 C60E      		add r12,r22
 1059 049a D71E      		adc r13,r23
 1060 049c E81E      		adc r14,r24
 1061 049e F91E      		adc r15,r25
 282:main.c        ****     index ++;
 1063               	.LM87:
 1064 04a0 CF5F      		subi r28,lo8(-(1))
 1065               	.L16:
 279:main.c        ****   while(index  < window_size)
 1067               	.LM88:
 1068 04a2 AC2F      		mov r26,r28
 1069 04a4 B0E0      		ldi r27,0
 1070 04a6 A417      		cp r26,r20
 1071 04a8 B507      		cpc r27,r21
 1072 04aa 04F0      		brlt .L17
 283:main.c        ****   }
 284:main.c        **** 
 285:main.c        ****   rms = rawrms / window_size ;
 1074               	.LM89:
 1075 04ac 2D2F      		mov r18,r29
 1076 04ae 3327      		clr r19
 1077 04b0 27FD      		sbrc r18,7
 1078 04b2 3095      		com r19
 1079 04b4 432F      		mov r20,r19
 1080 04b6 532F      		mov r21,r19
 1081 04b8 C701      		movw r24,r14
 1082 04ba B601      		movw r22,r12
 1083 04bc 0E94 0000 		call __udivmodsi4
 286:main.c        ****   rms = sqrt(rms) ;
 1085               	.LM90:
 1086 04c0 CA01      		movw r24,r20
 1087 04c2 B901      		movw r22,r18
 1088 04c4 0E94 0000 		call __floatunsisf
 1089 04c8 0E94 0000 		call sqrt
 1090 04cc 0E94 0000 		call __fixunssfsi
 287:main.c        **** 
 288:main.c        ****     // No conversion needed as a =1 and b =0 in linear transformation
 289:main.c        ****     // convert to dB = 20 * log(average / (2 ^ (BitDepth - 1))) 
 290:main.c        ****     printf( "Audio RMS value =%ld\r\n",rms);
 1092               	.LM91:
 1093 04d0 9F93      		push r25
 1094 04d2 8F93      		push r24
 1095 04d4 7F93      		push r23
 1096 04d6 6F93      		push r22
 1097 04d8 80E0      		ldi r24,lo8(.LC16)
 1098 04da 90E0      		ldi r25,hi8(.LC16)
 1099 04dc 9F93      		push r25
 1100 04de 8F93      		push r24
 1101 04e0 0E94 0000 		call printf
 291:main.c        **** 
 292:main.c        ****   return 0;
 1103               	.LM92:
 1104 04e4 0F90      		pop __tmp_reg__
 1105 04e6 0F90      		pop __tmp_reg__
 1106 04e8 0F90      		pop __tmp_reg__
 1107 04ea 0F90      		pop __tmp_reg__
 1108 04ec 0F90      		pop __tmp_reg__
 1109 04ee 0F90      		pop __tmp_reg__
 293:main.c        **** }
 1111               	.LM93:
 1112 04f0 80E0      		ldi r24,0
 1113 04f2 90E0      		ldi r25,0
 1114               	/* epilogue start */
 1115 04f4 DF91      		pop r29
 1116 04f6 CF91      		pop r28
 1117 04f8 FF90      		pop r15
 1118 04fa EF90      		pop r14
 1119 04fc DF90      		pop r13
 1120 04fe CF90      		pop r12
 1121 0500 0895      		ret
 1127               	.Lscope3:
 1129               		.stabd	78,0,0
 1130               		.section	.rodata.str1.1
 1131               	.LC17:
 1132 01d6 5461 736B 		.string	"Task PID=%u\r\n"
 1132      2050 4944 
 1132      3D25 750D 
 1132      0A00 
 1133               		.text
 1135               	.global	collect_Audio_Data
 1137               	collect_Audio_Data:
 1138               		.stabd	46,0,0
 236:main.c        **** collect_Audio_Data(){
 1140               	.LM94:
 1141               	.LFBB4:
 1142 0502 CF93      		push r28
 1143 0504 DF93      		push r29
 1144 0506 00D0      		rcall .
 1145 0508 CDB7      		in r28,__SP_L__
 1146 050a DEB7      		in r29,__SP_H__
 1147               	/* prologue: function */
 1148               	/* frame size = 2 */
 1149               	/* stack size = 4 */
 1150               	.L__stack_usage = 4
 237:main.c        **** printf( "Task PID=%u\r\n",nrk_get_pid());
 1152               	.LM95:
 1153 050c 0E94 0000 		call nrk_get_pid
 1154 0510 1F92      		push __zero_reg__
 1155 0512 8F93      		push r24
 1156 0514 80E0      		ldi r24,lo8(.LC17)
 1157 0516 90E0      		ldi r25,hi8(.LC17)
 1158 0518 9F93      		push r25
 1159 051a 8F93      		push r24
 1160 051c 0E94 0000 		call printf
 244:main.c        **** fd=nrk_open(FIREFLY_3_SENSOR_BASIC,READ);
 1162               	.LM96:
 1163 0520 65E0      		ldi r22,lo8(5)
 1164 0522 83E0      		ldi r24,lo8(3)
 1165 0524 0E94 0000 		call nrk_open
 1166 0528 E82E      		mov r14,r24
 245:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 1168               	.LM97:
 1169 052a 0F90      		pop __tmp_reg__
 1170 052c 0F90      		pop __tmp_reg__
 1171 052e 0F90      		pop __tmp_reg__
 1172 0530 0F90      		pop __tmp_reg__
 1173 0532 8FEF      		ldi r24,lo8(-1)
 1174 0534 E812      		cpse r14,r24
 1175 0536 00C0      		rjmp .L23
 245:main.c        **** if(fd==NRK_ERROR) nrk_kprintf(PSTR("Failed to open sensor driver\r\n"));
 1177               	.LM98:
 1178 0538 80E0      		ldi r24,lo8(__c.3186)
 1179 053a 90E0      		ldi r25,hi8(__c.3186)
 1180 053c 0E94 0000 		call nrk_kprintf
 1181               	.L23:
 236:main.c        **** collect_Audio_Data(){
 1183               	.LM99:
 1184 0540 00E0      		ldi r16,0
 1185 0542 10E0      		ldi r17,0
 1186 0544 F12C      		mov r15,__zero_reg__
 1187               	.L20:
 249:main.c        **** 		val=nrk_set_status(fd,SENSOR_SELECT,AUDIO);
 1189               	.LM100:
 1190 0546 43E0      		ldi r20,lo8(3)
 1191 0548 61E0      		ldi r22,lo8(1)
 1192 054a 8E2D      		mov r24,r14
 1193 054c 0E94 0000 		call nrk_set_status
 251:main.c        **** 		nrk_spin_wait_us(125);
 1195               	.LM101:
 1196 0550 8DE7      		ldi r24,lo8(125)
 1197 0552 90E0      		ldi r25,0
 1198 0554 0E94 0000 		call nrk_spin_wait_us
 252:main.c        **** 		val=nrk_read(fd,&buf,2);
 1200               	.LM102:
 1201 0558 42E0      		ldi r20,lo8(2)
 1202 055a BE01      		movw r22,r28
 1203 055c 6F5F      		subi r22,-1
 1204 055e 7F4F      		sbci r23,-1
 1205 0560 8E2D      		mov r24,r14
 1206 0562 0E94 0000 		call nrk_read
 256:main.c        **** 		nrk_led_clr(BLUE_LED);
 1208               	.LM103:
 1209 0566 83E0      		ldi r24,lo8(3)
 1210 0568 90E0      		ldi r25,0
 1211 056a 0E94 0000 		call nrk_led_clr
 257:main.c        **** 		nrk_led_clr(RED_LED);
 1213               	.LM104:
 1214 056e 80E0      		ldi r24,0
 1215 0570 90E0      		ldi r25,0
 1216 0572 0E94 0000 		call nrk_led_clr
 258:main.c        **** 		nrk_led_toggle(RED_LED);
 1218               	.LM105:
 1219 0576 80E0      		ldi r24,0
 1220 0578 90E0      		ldi r25,0
 1221 057a 0E94 0000 		call nrk_led_toggle
 260:main.c        **** 		audio_data[index] = buf;
 1223               	.LM106:
 1224 057e 2091 0000 		lds r18,audio_data
 1225 0582 3091 0000 		lds r19,audio_data+1
 1226 0586 4981      		ldd r20,Y+1
 1227 0588 5A81      		ldd r21,Y+2
 1228 058a F901      		movw r30,r18
 1229 058c E00F      		add r30,r16
 1230 058e F11F      		adc r31,r17
 1231 0590 5183      		std Z+1,r21
 1232 0592 4083      		st Z,r20
 261:main.c        **** 		index++;
 1234               	.LM107:
 1235 0594 F394      		inc r15
 263:main.c        **** 		if(index == audio_data_size)
 1237               	.LM108:
 1238 0596 8091 0000 		lds r24,audio_data_size
 1239 059a 0E5F      		subi r16,-2
 1240 059c 1F4F      		sbci r17,-1
 1241 059e F812      		cpse r15,r24
 1242 05a0 00C0      		rjmp .L20
 266:main.c        **** 			calculate_rms(audio_data, audio_data_size);
 1244               	.LM109:
 1245 05a2 6F2D      		mov r22,r15
 1246 05a4 C901      		movw r24,r18
 1247 05a6 0E94 0000 		call calculate_rms
 1248 05aa 00C0      		rjmp .L23
 1255               	.Lscope4:
 1257               		.stabd	78,0,0
 1259               	.global	nrk_register_drivers
 1261               	nrk_register_drivers:
 1262               		.stabd	46,0,0
 294:main.c        **** 
 295:main.c        **** 
 296:main.c        **** void nrk_register_drivers()
 297:main.c        **** {
 1264               	.LM110:
 1265               	.LFBB5:
 1266               	/* prologue: function */
 1267               	/* frame size = 0 */
 1268               	/* stack size = 0 */
 1269               	.L__stack_usage = 0
 298:main.c        **** int8_t val;
 299:main.c        **** 
 300:main.c        **** // Register the Basic FireFly Sensor device driver
 301:main.c        **** // Make sure to add: 
 302:main.c        **** //     #define NRK_MAX_DRIVER_CNT  
 303:main.c        **** //     in nrk_cfg.h
 304:main.c        **** // Make sure to add: 
 305:main.c        **** //     SRC += $(ROOT_DIR)/src/drivers/platform/$(PLATFORM_TYPE)/source/ff_basic_sensor.c
 306:main.c        **** //     in makefile
 307:main.c        **** val=nrk_register_driver( &dev_manager_ff3_sensors,FIREFLY_3_SENSOR_BASIC);
 1271               	.LM111:
 1272 05ac 63E0      		ldi r22,lo8(3)
 1273 05ae 80E0      		ldi r24,lo8(gs(dev_manager_ff3_sensors))
 1274 05b0 90E0      		ldi r25,hi8(gs(dev_manager_ff3_sensors))
 1275 05b2 0E94 0000 		call nrk_register_driver
 308:main.c        **** if(val==NRK_ERROR) nrk_kprintf( PSTR("Failed to load my ADC driver\r\n") );
 1277               	.LM112:
 1278 05b6 8F3F      		cpi r24,lo8(-1)
 1279 05b8 01F4      		brne .L24
 1281               	.LM113:
 1282 05ba 80E0      		ldi r24,lo8(__c.3203)
 1283 05bc 90E0      		ldi r25,hi8(__c.3203)
 1284 05be 0C94 0000 		jmp nrk_kprintf
 1285               	.L24:
 1286 05c2 0895      		ret
 1288               	.Lscope5:
 1290               		.stabd	78,0,0
 1291               		.section	.rodata.str1.1
 1292               	.LC18:
 1293 01e4 7374 6172 		.string	"starting...\r"
 1293      7469 6E67 
 1293      2E2E 2E0D 
 1293      00
 1294               		.section	.text.startup,"ax",@progbits
 1296               	.global	main
 1298               	main:
 1299               		.stabd	46,0,0
  57:main.c        **** {
 1301               	.LM114:
 1302               	.LFBB6:
 1303               	/* prologue: function */
 1304               	/* frame size = 0 */
 1305               	/* stack size = 0 */
 1306               	.L__stack_usage = 0
  59:main.c        ****   nrk_setup_ports();
 1308               	.LM115:
 1309 0000 0E94 0000 		call nrk_setup_ports
  60:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 1311               	.LM116:
 1312 0004 80E1      		ldi r24,lo8(16)
 1313 0006 90E0      		ldi r25,0
 1314 0008 0E94 0000 		call nrk_setup_uart
  63:main.c        ****   printf( PSTR("starting...\r\n") );
 1316               	.LM117:
 1317 000c 80E0      		ldi r24,lo8(.LC18)
 1318 000e 90E0      		ldi r25,hi8(.LC18)
 1319 0010 0E94 0000 		call puts
  65:main.c        ****   audio_data_size = 30;
 1321               	.LM118:
 1322 0014 8EE1      		ldi r24,lo8(30)
 1323 0016 8093 0000 		sts audio_data_size,r24
  66:main.c        ****   audio_data = malloc(audio_data_size * (sizeof audio_data[0]));
 1325               	.LM119:
 1326 001a 8CE3      		ldi r24,lo8(60)
 1327 001c 90E0      		ldi r25,0
 1328 001e 0E94 0000 		call malloc
 1329 0022 8093 0000 		sts audio_data,r24
 1330 0026 9093 0000 		sts audio_data+1,r25
  68:main.c        ****   nrk_init();
 1332               	.LM120:
 1333 002a 0E94 0000 		call nrk_init
  69:main.c        ****   nrk_time_set(0,0);
 1335               	.LM121:
 1336 002e 20E0      		ldi r18,0
 1337 0030 30E0      		ldi r19,0
 1338 0032 A901      		movw r20,r18
 1339 0034 60E0      		ldi r22,0
 1340 0036 70E0      		ldi r23,0
 1341 0038 CB01      		movw r24,r22
 1342 003a 0E94 0000 		call nrk_time_set
  71:main.c        ****   nrk_register_drivers();
 1344               	.LM122:
 1345 003e 0E94 0000 		call nrk_register_drivers
  72:main.c        ****   nrk_create_taskset ();
 1347               	.LM123:
 1348 0042 0E94 0000 		call nrk_create_taskset
  73:main.c        ****   nrk_start();
 1350               	.LM124:
 1351 0046 0E94 0000 		call nrk_start
  76:main.c        **** }
 1353               	.LM125:
 1354 004a 80E0      		ldi r24,0
 1355 004c 90E0      		ldi r25,0
 1356 004e 0895      		ret
 1358               	.Lscope6:
 1360               		.stabd	78,0,0
 1361               		.comm	audio_data_size,1,1
 1362               		.comm	audio_data,2,1
 1363               		.comm	Stack2,128,1
 1364               		.comm	TaskTwo,35,1
 1365               		.comm	TaskOne,35,1
 1366               		.comm	Stack1,128,1
 1367               		.comm	app_timer0_prescale,1,1
 1368               		.comm	app_timer0_callback,2,1
 1369               		.comm	_nrk_time_trigger,1,1
 1370               		.comm	_nrk_prev_timer_val,1,1
 1371               		.comm	error_num,1,1
 1372               		.comm	error_task,1,1
 1373               		.comm	nrk_kernel_stk_ptr,2,1
 1374               		.comm	nrk_idle_task_stk,128,1
 1375               		.comm	_nrk_signal_list,4,1
 1376               		.section	.progmem.data,"a",@progbits
 1379               	__c.3168:
 1380 0000 4661 696C 		.string	"Failed to open sensor driver\r\n"
 1380      6564 2074 
 1380      6F20 6F70 
 1380      656E 2073 
 1380      656E 736F 
 1383               	__c.3186:
 1384 001f 4661 696C 		.string	"Failed to open sensor driver\r\n"
 1384      6564 2074 
 1384      6F20 6F70 
 1384      656E 2073 
 1384      656E 736F 
 1387               	__c.3203:
 1388 003e 4661 696C 		.string	"Failed to load my ADC driver\r\n"
 1388      6564 2074 
 1388      6F20 6C6F 
 1388      6164 206D 
 1388      7920 4144 
 1404               		.text
 1406               	.Letext0:
 1407               		.ident	"GCC: (GNU) 4.7.2"
 1408               	.global __do_copy_data
 1409               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:4      *ABS*:000000000000003f __SREG__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:330    .text:0000000000000000 print_sensor_readings
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:1379   .progmem.data:0000000000000000 __c.3168
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:831    .text:0000000000000318 nrk_create_taskset
                            *COM*:0000000000000023 TaskOne
                            *COM*:0000000000000080 Stack1
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:1137   .text:0000000000000502 collect_Audio_Data
                            *COM*:0000000000000023 TaskTwo
                            *COM*:0000000000000080 Stack2
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:1014   .text:0000000000000462 calculate_rms
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:1383   .progmem.data:000000000000001f __c.3186
                            *COM*:0000000000000002 audio_data
                            *COM*:0000000000000001 audio_data_size
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:1261   .text:00000000000005ac nrk_register_drivers
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:1387   .progmem.data:000000000000003e __c.3203
/var/folders/7t/5z8zx9ys69n2cs122c_s48hh0000gn/T//cc83qKcB.s:1298   .text.startup:0000000000000000 main
                            *COM*:0000000000000001 app_timer0_prescale
                            *COM*:0000000000000002 app_timer0_callback
                            *COM*:0000000000000001 _nrk_time_trigger
                            *COM*:0000000000000001 _nrk_prev_timer_val
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000080 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
__udivdi3
__muldi3
printf
nrk_get_pid
nrk_open
nrk_kprintf
nrk_set_status
nrk_read
__ashldi3
__adddi3
__udivmodhi4
nrk_led_clr
putchar
puts
nrk_led_toggle
nrk_wait_until_next_period
nrk_task_set_stk
nrk_activate_task
nrk_task_set_entry_function
__floatunsisf
__fixunssfsi
__umulhisi3
__udivmodsi4
sqrt
nrk_spin_wait_us
dev_manager_ff3_sensors
nrk_register_driver
nrk_setup_ports
nrk_setup_uart
malloc
nrk_init
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
